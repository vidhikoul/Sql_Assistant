Overview — Trino 474 Documentation Skip to content Trino 474 Documentation Overview  Type to start searching Trino Trino 474 Documentation Trino Overview Overview Use cases Trino concepts Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax Developer guide Glossary Appendix Release notes Overview # Trino is a distributed SQL query engine designed to query large data sets distributed over one or more heterogeneous data sources. Use cases Trino concepts Previous Trino documentation Next Use cases

Installation — Trino 474 Documentation Skip to content Trino 474 Documentation Installation  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Installation Deploying Trino Trino in a Docker container Trino on Kubernetes with Helm Plugins Improve query processing resilience Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax Developer guide Glossary Appendix Release notes Installation # A Trino server can be installed and deployed on a number of different platforms. Typically you run a cluster of machines with one coordinator and many workers. You can find instructions for deploying such a cluster, and related information, in the following sections: Deploying Trino Trino in a Docker container Trino on Kubernetes with Helm Plugins Improve query processing resilience Once you have a completed the deployment, or if you have access to a running cluster already, you can proceed to configure your client application . Previous Trino concepts Next Deploying Trino

Clients — Trino 474 Documentation Skip to content Trino 474 Documentation Clients  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Clients Contents Client drivers Client applications Client protocol Client protocol Command line interface JDBC driver Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax Developer guide Glossary Appendix Release notes Contents Client drivers Client applications Client protocol Clients # A client is used to send SQL queries to Trino, and therefore any connected data sources , and receive results. Client drivers # Client drivers, also called client libraries, provide a mechanism for other applications to connect to Trino. The application are called client application and include your own custom applications or scripts. The Trino project maintains the following client drivers: Trino JDBC driver trino-go-client trino-js-client trino-python-client trino-csharp-client Other communities and vendors provide other client drivers . Client applications # Client applications provide a user interface and other user-facing features to run queries with Trino. You can inspect the results, perform analytics with further queries, and create visualizations. Client applications typically use a client driver. The Trino project maintains the Trino command line interface and the Trino Grafana Data Source Plugin as a client application. Other communities and vendors provide numerous other client applications Client protocol # All client drivers and client applications communicate with the Trino coordinator using the client protocol . Configure support for the spooling protocol on the cluster to improve throughput for client interactions with higher data transfer demands. Client protocol Command line interface JDBC driver Previous Improve query processing resilience Next Client protocol

Security — Trino 474 Documentation Skip to content Trino 474 Documentation Security  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Security Contents Introduction Cluster access security Authentication User name management Access control Security inside the cluster Security overview TLS and HTTPS PEM files JKS files Authentication types Password file authentication LDAP authentication Salesforce authentication OAuth 2.0 authentication Kerberos authentication Certificate authentication JWT authentication User mapping File group provider System access control File-based access control Open Policy Agent access control Ranger access control Secure internal communication Secrets Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax Developer guide Glossary Appendix Release notes Contents Introduction Cluster access security Authentication User name management Access control Security inside the cluster Security # Introduction # Security overview Cluster access security # TLS and HTTPS PEM files JKS files Authentication # Authentication types Password file authentication LDAP authentication Salesforce authentication OAuth 2.0 authentication Kerberos authentication Certificate authentication JWT authentication User name management # User mapping File group provider Access control # System access control File-based access control Open Policy Agent access control Ranger access control Security inside the cluster # Secure internal communication Secrets Previous JDBC driver Next Security overview

Administration — Trino 474 Documentation Skip to content Trino 474 Documentation Administration  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Administration Contents Event listeners Properties reference Web UI Preview Web UI Logging Tuning Trino Monitoring with JMX Observability with OpenTelemetry Trino metrics with OpenMetrics Properties reference Spill to disk Resource groups Session property managers Distributed sort Dynamic filtering Graceful shutdown Fault-tolerant execution HTTP event listener Kafka event listener MySQL event listener OpenLineage event listener Properties reference Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax Developer guide Glossary Appendix Release notes Contents Event listeners Properties reference Administration # The following documents cover a number of different aspect of configuring, running, and managing Trino clusters. Web UI Preview Web UI Logging Tuning Trino Monitoring with JMX Observability with OpenTelemetry Trino metrics with OpenMetrics Properties reference Spill to disk Resource groups Session property managers Distributed sort Dynamic filtering Graceful shutdown Fault-tolerant execution Details about connecting data sources as catalogs are available in the connector documentation . Event listeners # Event listeners are plugins that allow streaming of query events, such as query started or query finished, to an external system. Using an event listener you can process and store the query events in a separate system for long periods of time. Some of these external systems can be queried with Trino for further analysis or reporting. The following event listeners are available: HTTP event listener Kafka event listener MySQL event listener OpenLineage event listener Unrelated to event listeners, the coordinator stores information about recent queries in memory for usage by the Web UI - see also query.max-history and query.min-expire-age in Query management properties . Properties reference # Many aspects for running Trino are configured with properties . The following pages provide an overview and details for specific topics. Properties reference overview General properties Client protocol properties HTTP server properties Resource management properties Query management properties Catalog management properties SQL environment properties Spilling properties Exchange properties Task properties Write partitioning properties Writer scaling properties Node scheduler properties Optimizer properties Logging properties Web UI properties Regular expression function properties HTTP client properties Previous Secrets Next Web UI

Query optimizer — Trino 474 Documentation Skip to content Trino 474 Documentation Query optimizer  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Query optimizer Table statistics Cost in EXPLAIN Cost-based optimizations Pushdown Adaptive plan optimizations Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax Developer guide Glossary Appendix Release notes Query optimizer # Table statistics Cost in EXPLAIN Cost-based optimizations Pushdown Adaptive plan optimizations Previous OpenLineage event listener Next Table statistics

Connectors — Trino 474 Documentation Skip to content Trino 474 Documentation Connectors  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Connectors BigQuery Black Hole Cassandra ClickHouse Delta Lake Druid DuckDB Elasticsearch Exasol Faker Google Sheets Hive Hudi Iceberg Ignite JMX Kafka Loki MariaDB Memory MongoDB MySQL OpenSearch Oracle Pinot PostgreSQL Prometheus Redis Redshift SingleStore Snowflake SQL Server System Thrift TPC-DS TPC-H Vertica 404 - Connector removed Object storage Functions and operators User-defined functions SQL language SQL statement syntax Developer guide Glossary Appendix Release notes Connectors # This section describes the connectors available in Trino to access data from different data sources by configuring catalogs with the connector-specific properties in catalog properties files . BigQuery Black Hole Cassandra ClickHouse Delta Lake Druid DuckDB Elasticsearch Exasol Faker Google Sheets Hive Hudi Iceberg Ignite JMX Kafka Loki MariaDB Memory MongoDB MySQL OpenSearch Oracle Pinot PostgreSQL Prometheus Redis Redshift SingleStore Snowflake SQL Server System Thrift TPC-DS TPC-H Vertica Previous Adaptive plan optimizations Next BigQuery connector

Object storage — Trino 474 Documentation Skip to content Trino 474 Documentation Object storage  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Object storage Contents Object storage connectors Configuration Native file system support Legacy file system support Other object storage support Azure Storage file system support Google Cloud Storage file system support S3 file system support Local file system support HDFS file system support File system cache Alluxio file system support Metastores Object storage file formats Functions and operators User-defined functions SQL language SQL statement syntax Developer guide Glossary Appendix Release notes Contents Object storage connectors Configuration Native file system support Legacy file system support Other object storage support Object storage # Object storage systems are commonly used to create data lakes or data lake houses. These systems provide methods to store objects in a structured manner and means to access them, for example using an API over HTTP. The objects are files in various format including ORC, Parquet and others. Object storage systems are available as service from public cloud providers and others vendors, or can be self-hosted using commercial as well as open source offerings. Object storage connectors # Trino accesses files directly on object storage and remote file system storage. The following connectors use this direct approach to read and write data files. Delta Lake connector Hive connector Hudi connector Iceberg connector The connectors all support a variety of protocols and formats used on these object storage systems, and have separate requirements for metadata availability. Configuration # By default, no file system support is activated for your catalog. You must select and configure one of the following properties to determine the support for different file systems in the catalog. Each catalog can only use one file system support. File system support properties # Property Description fs.native-azure.enabled Activate the native implementation for Azure Storage support . Defaults to false . fs.native-gcs.enabled Activate the native implementation for Google Cloud Storage support . Defaults to false . fs.native-s3.enabled Activate the native implementation for S3 storage support . Defaults to false . fs.hadoop.enabled Activate support for HDFS and legacy support for other file systems using the HDFS libraries. Defaults to false . Native file system support # Trino includes optimized implementations to access the following systems, and compatible replacements: Azure Storage file system support Google Cloud Storage file system support S3 file system support Local file system support Alluxio file system support The native support is available in all four connectors, and must be activated for use. Legacy file system support # The default behavior uses legacy libraries that originate from the Hadoop ecosystem. It should only be used for accessing the Hadoop Distributed File System (HDFS): HDFS file system support All four connectors can use the deprecated hive.* properties for access to other object storage system as legacy support. These properties will be removed in a future release. Additional documentation is available with the Hive connector and relevant migration guides pages: Hive connector Azure Storage migration from hive.azure.* properties Google Cloud Storage migration from hive.gcs.* properties S3 migration from hive.s3.* properties Other object storage support # Trino also provides the following additional support and features for object storage: File system cache Alluxio file system support Metastores Object storage file formats Previous 404 - Connector removed Next Azure Storage file system support

Functions and operators — Trino 474 Documentation Skip to content Trino 474 Documentation Functions and operators  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators Functions and operators Contents Functions by name Functions per topic List of functions and operators List of functions by topic Aggregate AI Array Binary Bitwise Color Comparison Conditional Conversion Date and time Decimal Geospatial HyperLogLog IP Address JSON Lambda Logical Machine learning Map Math Quantile digest Regular expression Session Set Digest String System Table Teradata T-Digest URL UUID Window User-defined functions SQL language SQL statement syntax Developer guide Glossary Appendix Release notes Contents Functions by name Functions per topic Functions and operators # This section describes the built-in SQL functions and operators supported by Trino. They allow you to implement complex capabilities and behavior of the queries executed by Trino operating on the underlying data sources. Refer to the following sections for further details: SQL data types and other general aspects SQL statement and syntax reference In addition, Trino supports implementation of custom functions or custom table functions provided by a plugin, and creation of User-defined functions . Functions by name # If you are looking for a specific function or operator by name use SHOW FUNCTIONS , or refer to the following resources: List of functions and operators List of functions by topic Functions per topic # Aggregate AI Array Binary Bitwise Color Comparison Conditional Conversion Date and time Decimal Geospatial HyperLogLog IP Address JSON Lambda Logical Machine learning Map Math Quantile digest Regular expression Session Set Digest String System Table Teradata T-Digest URL UUID Window Previous Object storage file formats Next List of functions and operators

User-defined functions — Trino 474 Documentation Skip to content Trino 474 Documentation User-defined functions  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions User-defined functions Introduction to UDFs FUNCTION SQL user-defined functions Python user-defined functions SQL language SQL statement syntax Developer guide Glossary Appendix Release notes User-defined functions # A user-defined function (UDF) is a custom function authored by a user of Trino in a client application. UDFs are scalar functions that return a single output value, similar to built-in functions . More details are available in the following sections: Introduction to UDFs FUNCTION SQL user-defined functions Python user-defined functions Previous Window functions Next Introduction to UDFs

SQL language — Trino 474 Documentation Skip to content Trino 474 Documentation SQL language  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL language SQL statement support Data types Keywords and identifiers Comments SQL statement syntax Developer guide Glossary Appendix Release notes SQL language # Trino is an ANSI SQL compliant query engine. This standard compliance allows Trino users to integrate their favorite data tools, including BI and ETL tools with any underlying data source. Trino validates and translates the received SQL statements into the necessary operations on the connected data source. This section provides a reference to the supported SQL data types and other general characteristics of the SQL support of Trino. Refer to the following sections for further details: SQL statement and syntax reference SQL functions and operators SQL statement support Globally available statements Read operations Write operations Security operations Transactions Data types Trino type support and mapping Boolean Integer Floating-point Exact numeric String Date and time Structural Network address UUID HyperLogLog SetDigest Quantile digest T-Digest Keywords and identifiers Comments Previous Example Python UDFs Next SQL statement support

Trino documentation — Trino 474 Documentation Skip to content Trino 474 Documentation Trino documentation  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax Developer guide Glossary Appendix Release notes Trino documentation # Overview Use cases Trino concepts Installation Deploying Trino Trino in a Docker container Trino on Kubernetes with Helm Plugins Improve query processing resilience Clients Client protocol Command line interface JDBC driver Security Security overview TLS and HTTPS PEM files JKS files Authentication types Password file authentication LDAP authentication Salesforce authentication OAuth 2.0 authentication Kerberos authentication Certificate authentication JWT authentication User mapping File group provider System access control File-based access control Open Policy Agent access control Ranger access control Secure internal communication Secrets Administration Web UI Preview Web UI Logging Tuning Trino Monitoring with JMX Observability with OpenTelemetry Trino metrics with OpenMetrics Properties reference General Client protocol HTTP server Resource management Query management Catalog management SQL environment Spilling Exchange Task Write partitioning Writer scaling Node scheduler Optimizer Logging Web UI Regular expression function HTTP client Spill to disk Resource groups Session property managers Distributed sort Dynamic filtering Graceful shutdown Fault-tolerant execution HTTP event listener Kafka event listener MySQL event listener OpenLineage event listener Query optimizer Table statistics Cost in EXPLAIN Cost-based optimizations Pushdown Adaptive plan optimizations Connectors BigQuery Black Hole Cassandra ClickHouse Delta Lake Druid DuckDB Elasticsearch Exasol Faker Google Sheets Hive Hudi Iceberg Ignite JMX Kafka Loki MariaDB Memory MongoDB MySQL OpenSearch Oracle Pinot PostgreSQL Prometheus Redis Redshift SingleStore Snowflake SQL Server System Thrift TPC-DS TPC-H Vertica Object storage Functions and operators List of functions and operators List of functions by topic Aggregate AI Array Binary Bitwise Color Comparison Conditional Conversion Date and time Decimal Geospatial HyperLogLog IP Address JSON Lambda Logical Machine learning Map Math Quantile digest Regular expression Session Set Digest String System Table Teradata T-Digest URL UUID Window User-defined functions Introduction to UDFs FUNCTION SQL user-defined functions Python user-defined functions SQL language SQL statement support Data types Keywords and identifiers Comments SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Developer guide SPI overview Test writing guidelines Connectors Example HTTP connector Example JDBC connector Supporting INSERT and CREATE TABLE AS Supporting MERGE Types Functions Table functions System access control Password authenticator Certificate authenticator Header authenticator Group provider Event listener Trino client REST API Glossary Appendix Migrating from Hive Legal notices Release notes Next Overview

ALTER MATERIALIZED VIEW — Trino 474 Documentation Skip to content Trino 474 Documentation ALTER MATERIALIZED VIEW  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER MATERIALIZED VIEW Contents Synopsis Description SET PROPERTIES Examples See also ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description SET PROPERTIES Examples See also ALTER MATERIALIZED VIEW # Synopsis # ALTER MATERIALIZED VIEW [ IF EXISTS ] name RENAME TO new_name ALTER MATERIALIZED VIEW name SET PROPERTIES property_name = expression [, ...] Description # Change the name of an existing materialized view. The optional IF EXISTS clause causes the error to be suppressed if the materialized view does not exist. The error is not suppressed if the materialized view does not exist, but a table or view with the given name exists. SET PROPERTIES # The ALTER MATERIALIZED VIEW SET PROPERTIES statement followed by some number of property_name and expression pairs applies the specified properties and values to a materialized view. Ommitting an already-set property from this statement leaves that property unchanged in the materialized view. A property in a SET PROPERTIES statement can be set to DEFAULT , which reverts its value back to the default in that materialized view. Support for ALTER MATERIALIZED VIEW SET PROPERTIES varies between connectors. Refer to the connector documentation for more details. Examples # Rename materialized view people to users in the current schema: ALTER MATERIALIZED VIEW people RENAME TO users ; Rename materialized view people to users , if materialized view people exists in the current catalog and schema: ALTER MATERIALIZED VIEW IF EXISTS people RENAME TO users ; Set view properties ( x = y ) in materialized view people : ALTER MATERIALIZED VIEW people SET PROPERTIES x = 'y' ; Set multiple view properties ( foo = 123 and foo bar = 456 ) in materialized view people : ALTER MATERIALIZED VIEW people SET PROPERTIES foo = 123 , "foo bar" = 456 ; Set view property x to its default value in materialized view people : ALTER MATERIALIZED VIEW people SET PROPERTIES x = DEFAULT ; See also # CREATE MATERIALIZED VIEW REFRESH MATERIALIZED VIEW DROP MATERIALIZED VIEW Previous SQL statement syntax Next ALTER SCHEMA

ALTER SCHEMA — Trino 474 Documentation Skip to content Trino 474 Documentation ALTER SCHEMA  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER SCHEMA Contents Synopsis Description Examples See Also ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See Also ALTER SCHEMA # Synopsis # ALTER SCHEMA name RENAME TO new_name ALTER SCHEMA name SET AUTHORIZATION ( user | USER user | ROLE role ) Description # Change the definition of an existing schema. Examples # Rename schema web to traffic : ALTER SCHEMA web RENAME TO traffic Change owner of schema web to user alice : ALTER SCHEMA web SET AUTHORIZATION alice Allow everyone to drop schema and create tables in schema web : ALTER SCHEMA web SET AUTHORIZATION ROLE PUBLIC See Also # CREATE SCHEMA Previous ALTER MATERIALIZED VIEW Next ALTER TABLE

ALTER TABLE — Trino 474 Documentation Skip to content Trino 474 Documentation ALTER TABLE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER TABLE Contents Synopsis Description SET PROPERTIES EXECUTE Examples See also ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description SET PROPERTIES EXECUTE Examples See also ALTER TABLE # Synopsis # ALTER TABLE [ IF EXISTS ] name RENAME TO new_name ALTER TABLE [ IF EXISTS ] name ADD COLUMN [ IF NOT EXISTS ] column_name data_type [ NOT NULL ] [ COMMENT comment ] [ WITH ( property_name = expression [, ...] ) ] [ FIRST | LAST | AFTER after_column_name ] ALTER TABLE [ IF EXISTS ] name DROP COLUMN [ IF EXISTS ] column_name ALTER TABLE [ IF EXISTS ] name RENAME COLUMN [ IF EXISTS ] old_name TO new_name ALTER TABLE [ IF EXISTS ] name ALTER COLUMN column_name SET DATA TYPE new_type ALTER TABLE [ IF EXISTS ] name ALTER COLUMN column_name DROP NOT NULL ALTER TABLE name SET AUTHORIZATION ( user | USER user | ROLE role ) ALTER TABLE name SET PROPERTIES property_name = expression [, ...] ALTER TABLE name EXECUTE command [ ( parameter => expression [, ... ] ) ] [ WHERE expression ] Description # Change the definition of an existing table. The optional IF EXISTS clause, when used before the table name, causes the error to be suppressed if the table does not exist. The optional IF EXISTS clause, when used before the column name, causes the error to be suppressed if the column does not exist. The optional IF NOT EXISTS clause causes the error to be suppressed if the column already exists. SET PROPERTIES # The ALTER TABLE SET PROPERTIES statement followed by a number of property_name and expression pairs applies the specified properties and values to a table. Ommitting an already-set property from this statement leaves that property unchanged in the table. A property in a SET PROPERTIES statement can be set to DEFAULT , which reverts its value back to the default in that table. Support for ALTER TABLE SET PROPERTIES varies between connectors, as not all connectors support modifying table properties. EXECUTE # The ALTER TABLE EXECUTE statement followed by a command and parameters modifies the table according to the specified command and parameters. ALTER TABLE EXECUTE supports different commands on a per-connector basis. You can use the => operator for passing named parameter values. The left side is the name of the parameter, the right side is the value being passed. Executable commands are contributed by connectors, such as the optimize command provided by the Hive , Delta Lake , and Iceberg connectors. For example, a user observing many small files in the storage of a table called test_table in the test schema of the example catalog, can use the optimize command to merge all files below the file_size_threshold value. The result is fewer, but larger files, which typically results in higher query performance on the data in the files: ALTER TABLE example . test . test_table EXECUTE optimize ( file_size_threshold => '16MB' ) Examples # Rename table users to people : ALTER TABLE users RENAME TO people ; Rename table users to people if table users exists: ALTER TABLE IF EXISTS users RENAME TO people ; Add column zip to the users table: ALTER TABLE users ADD COLUMN zip varchar ; Add column zip to the users table if table users exists and column zip not already exists: ALTER TABLE IF EXISTS users ADD COLUMN IF NOT EXISTS zip varchar ; Add column id as the first column to the users table: ALTER TABLE users ADD COLUMN id varchar FIRST ; Add column zip after column country to the users table: ALTER TABLE users ADD COLUMN zip varchar AFTER country ; Drop column zip from the users table: ALTER TABLE users DROP COLUMN zip ; Drop column zip from the users table if table users and column zip exists: ALTER TABLE IF EXISTS users DROP COLUMN IF EXISTS zip ; Rename column id to user_id in the users table: ALTER TABLE users RENAME COLUMN id TO user_id ; Rename column id to user_id in the users table if table users and column id exists: ALTER TABLE IF EXISTS users RENAME column IF EXISTS id to user_id ; Change type of column id to bigint in the users table: ALTER TABLE users ALTER COLUMN id SET DATA TYPE bigint ; Drop a not null constraint on id column in the users table: ALTER TABLE users ALTER COLUMN id DROP NOT NULL ; Change owner of table people to user alice : ALTER TABLE people SET AUTHORIZATION alice Allow everyone with role public to drop and alter table people : ALTER TABLE people SET AUTHORIZATION ROLE PUBLIC Set table properties ( x = y ) in table people : ALTER TABLE people SET PROPERTIES x = 'y' ; Set multiple table properties ( foo = 123 and foo bar = 456 ) in table people : ALTER TABLE people SET PROPERTIES foo = 123 , "foo bar" = 456 ; Set table property x to its default value in table``people``: ALTER TABLE people SET PROPERTIES x = DEFAULT ; See also # CREATE TABLE Previous ALTER SCHEMA Next ALTER VIEW

ALTER VIEW — Trino 474 Documentation Skip to content Trino 474 Documentation ALTER VIEW  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ALTER VIEW Contents Synopsis Description Examples See also ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also ALTER VIEW # Synopsis # ALTER VIEW name RENAME TO new_name ALTER VIEW name SET AUTHORIZATION ( user | USER user | ROLE role ) Description # Change the definition of an existing view. Examples # Rename view people to users : ALTER VIEW people RENAME TO users Change owner of VIEW people to user alice : ALTER VIEW people SET AUTHORIZATION alice See also # CREATE VIEW Previous ALTER TABLE Next ANALYZE

ANALYZE — Trino 474 Documentation Skip to content Trino 474 Documentation ANALYZE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE ANALYZE Contents Synopsis Description Examples CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples ANALYZE # Synopsis # ANALYZE table_name [ WITH ( property_name = expression [, ...] ) ] Description # Collects table and column statistics for a given table. The optional WITH clause can be used to provide connector-specific properties. To list all available properties, run the following query: SELECT * FROM system . metadata . analyze_properties Examples # Analyze table web to collect table and column statistics: ANALYZE web ; Analyze table stores in catalog hive and schema default : ANALYZE hive . default . stores ; Analyze partitions '1992-01-01', '1992-01-02' from a Hive partitioned table sales : ANALYZE hive . default . sales WITH ( partitions = ARRAY [ ARRAY [ '1992-01-01' ], ARRAY [ '1992-01-02' ]]); Analyze partitions with complex partition key ( state and city columns) from a Hive partitioned table customers : ANALYZE hive . default . customers WITH ( partitions = ARRAY [ ARRAY [ 'CA' , 'San Francisco' ], ARRAY [ 'NY' , 'NY' ]]); Analyze only columns department and product_id for partitions '1992-01-01', '1992-01-02' from a Hive partitioned table sales : ANALYZE hive . default . sales WITH ( partitions = ARRAY [ ARRAY [ '1992-01-01' ], ARRAY [ '1992-01-02' ]], columns = ARRAY [ 'department' , 'product_id' ]); Previous ALTER VIEW Next CALL

CALL — Trino 474 Documentation Skip to content Trino 474 Documentation CALL  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL CALL Contents Synopsis Description Examples COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples CALL # Synopsis # CALL procedure_name ( [ name => ] expression [, ...] ) Description # Call a procedure. Procedures can be provided by connectors to perform data manipulation or administrative tasks. For example, the System connector defines a procedure for killing a running query. Some connectors, such as the PostgreSQL connector , are for systems that have their own stored procedures. These stored procedures are separate from the connector-defined procedures discussed here and thus are not directly callable via CALL . See connector documentation for details on available procedures. Examples # Call a procedure using positional arguments: CALL test ( 123 , 'apple' ); Call a procedure using named arguments: CALL test ( name => 'apple' , id => 123 ); Call a procedure using a fully qualified name: CALL catalog . schema . test (); Previous ANALYZE Next COMMENT

COMMENT — Trino 474 Documentation Skip to content Trino 474 Documentation COMMENT  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMENT Contents Synopsis Description Examples See also COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also COMMENT # Synopsis # COMMENT ON ( TABLE | VIEW | COLUMN ) name IS 'comments' Description # Set the comment for a object. The comment can be removed by setting the comment to NULL . Examples # Change the comment for the users table to be master table : COMMENT ON TABLE users IS 'master table' ; Change the comment for the users view to be master view : COMMENT ON VIEW users IS 'master view' ; Change the comment for the users.name column to be full name : COMMENT ON COLUMN users . name IS 'full name' ; See also # Comments Previous CALL Next COMMIT

COMMIT — Trino 474 Documentation Skip to content Trino 474 Documentation COMMIT  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT COMMIT Contents Synopsis Description Examples See also CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also COMMIT # Synopsis # COMMIT [ WORK ] Description # Commit the current transaction. Examples # COMMIT ; COMMIT WORK ; See also # ROLLBACK , START TRANSACTION Previous COMMENT Next CREATE CATALOG

CREATE CATALOG — Trino 474 Documentation Skip to content Trino 474 Documentation CREATE CATALOG  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE CATALOG Contents Synopsis Description Examples See also CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also CREATE CATALOG # Synopsis # CREATE CATALOG catalog_name USING connector_name [ WITH ( property_name = expression [, ...] ) ] Description # Create a new catalog using the specified connector. The optional WITH clause is used to set properties on the newly created catalog. Property names can be double quoted, which is required if they contain special characters, like - . Refer to the connectors documentation to learn about all available properties. All property values must be varchars (single quoted), including numbers and boolean values. The query fails in the following circumstances: A required property is missing. An invalid property is set, for example there is a typo in the property name, or a property name from a different connector was used. The value of the property is invalid, for example a numeric value is out of range, or a string value doesn’t match the required pattern. The value references an environmental variable that is not set on the coordinator node. Warning The complete CREATE CATALOG query is logged, and visible in the Web UI . This includes any sensitive properties, like passwords and other credentials. See Secrets . Note This command requires the catalog management type to be set to dynamic . Examples # Create a new catalog called tpch using the TPC-H connector : CREATE CATALOG tpch USING tpch ; Create a new catalog called brain using the Memory connector : CREATE CATALOG brain USING memory WITH ( "memory.max-data-per-node" = '128MB' ); Notice that the connector property contains dashes ( - ) and needs to quoted using a double quote ( " ). The value 128MB is quoted using single quotes, because it is a string literal. Create a new catalog called example using the PostgreSQL connector : CREATE CATALOG example USING postgresql WITH ( "connection-url" = 'jdbc:pg:localhost:5432' , "connection-user" = '${ENV:POSTGRES_USER}' , "connection-password" = '${ENV:POSTGRES_PASSWORD}' , "case-insensitive-name-matching" = 'true' ); This example assumes that the POSTGRES_USER and POSTGRES_PASSWORD environmental variables are set as secrets on all nodes of the cluster. See also # DROP CATALOG Catalog management properties Previous COMMIT Next CREATE FUNCTION

CREATE FUNCTION — Trino 474 Documentation Skip to content Trino 474 Documentation CREATE FUNCTION  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE FUNCTION Contents Synopsis Description Examples See also CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also CREATE FUNCTION # Synopsis # CREATE [OR REPLACE] FUNCTION udf_definition Description # Create or replace a Catalog user-defined functions . The udf_definition is composed of the usage of FUNCTION and nested statements. The name of the UDF must be fully qualified with catalog and schema location, unless the default UDF storage catalog and schema are configured. The connector used in the catalog must support UDF storage. The optional OR REPLACE clause causes the UDF to be replaced if it already exists rather than raising an error. Examples # The following example creates the meaning_of_life UDF in the default schema of the example catalog: CREATE FUNCTION example . default . meaning_of_life () RETURNS bigint BEGIN RETURN 42 ; END ; If the default catalog and schema for UDF storage is configured, you can use the following more compact syntax: CREATE FUNCTION meaning_of_life () RETURNS bigint RETURN 42 ; Further examples of varying complexity that cover usage of the FUNCTION statement in combination with other statements are available in the SQL UDF examples documentation . See also # DROP FUNCTION SHOW CREATE FUNCTION SHOW FUNCTIONS User-defined functions SQL environment properties Previous CREATE CATALOG Next CREATE MATERIALIZED VIEW

CREATE MATERIALIZED VIEW — Trino 474 Documentation Skip to content Trino 474 Documentation CREATE MATERIALIZED VIEW  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE MATERIALIZED VIEW Contents Synopsis Description Examples See also CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also CREATE MATERIALIZED VIEW # Synopsis # CREATE [ OR REPLACE ] MATERIALIZED VIEW [ IF NOT EXISTS ] view_name [ GRACE PERIOD interval ] [ COMMENT string ] [ WITH properties ] AS query Description # Create and validate the definition of a new materialized view view_name of a SELECT query . You need to run the REFRESH MATERIALIZED VIEW statement after the creation to populate the materialized view with data. This materialized view is a physical manifestation of the query results at time of refresh. The data is stored, and can be referenced by future queries. Queries accessing materialized views are typically faster than retrieving data from a view created with the same query. Any computation, aggregation, and other operation to create the data is performed once during refresh of the materialized views, as compared to each time of accessing the view. Multiple reads of view data over time, or by multiple users, all trigger repeated processing. This is avoided for materialized views. The optional OR REPLACE clause causes the materialized view to be replaced if it already exists rather than raising an error. The optional IF NOT EXISTS clause causes the materialized view only to be created if it does not exist yet. Note that OR REPLACE and IF NOT EXISTS are mutually exclusive clauses. The optional GRACE PERIOD clause specifies how long the query materialization is used for querying: Within the grace period since last refresh, data retrieval is highly performant because the query materialization is used. However, the data may not be up to date with the base tables. After the grace period has elapsed, the data of the materialized view is computed on-the-fly using the query . Retrieval is therefore slower, but the data is up to date with the base tables. If not specified, the grace period defaults to infinity, and therefore all queries are within the grace period. Every REFRESH MATERIALIZED VIEW operation resets the start time for the grace period. The optional COMMENT clause causes a string comment to be stored with the metadata about the materialized view. The comment is displayed with the SHOW CREATE MATERIALIZED VIEW statement and is available in the table system.metadata.materialized_view_properties . The optional WITH clause is used to define properties for the materialized view creation. Separate multiple property/value pairs by commas. The connector uses the properties as input parameters for the materialized view refresh operation. The supported properties are different for each connector and detailed in the SQL support section of the specific connector’s documentation. After successful creation, all metadata about the materialized view is available in a system table . Examples # Create a simple materialized view cancelled_orders over the orders table that only includes cancelled orders. Note that orderstatus is a numeric value that is potentially meaningless to a consumer, yet the name of the view clarifies the content: CREATE MATERIALIZED VIEW cancelled_orders AS SELECT orderkey , totalprice FROM orders WHERE orderstatus = 3 ; Create or replace a materialized view order_totals_by_date that summarizes orders across all orders from all customers: CREATE OR REPLACE MATERIALIZED VIEW order_totals_by_date AS SELECT orderdate , sum ( totalprice ) AS price FROM orders GROUP BY orderdate ; Create a materialized view for a catalog using the Iceberg connector, with a comment and partitioning on two fields in the storage: CREATE MATERIALIZED VIEW orders_nation_mkgsegment COMMENT 'Orders with nation and market segment data' WITH ( partitioning = ARRAY [ 'mktsegment' , 'nationkey' ] ) AS SELECT o . * , c . nationkey , c . mktsegment FROM orders AS o JOIN customer AS c ON o . custkey = c . custkey ; Set multiple properties: WITH ( format = 'ORC' , partitioning = ARRAY [ '_date' ] ) Show defined materialized view properties for all catalogs: SELECT * FROM system . metadata . materialized_view_properties ; Show metadata about the materialized views in all catalogs: SELECT * FROM system . metadata . materialized_views ; See also # DROP MATERIALIZED VIEW SHOW CREATE MATERIALIZED VIEW REFRESH MATERIALIZED VIEW Previous CREATE FUNCTION Next CREATE ROLE

CREATE ROLE — Trino 474 Documentation Skip to content Trino 474 Documentation CREATE ROLE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE ROLE Contents Synopsis Description Examples Limitations See also CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples Limitations See also CREATE ROLE # Synopsis # CREATE ROLE role_name [ WITH ADMIN ( user | USER user | ROLE role | CURRENT_USER | CURRENT_ROLE ) ] [ IN catalog ] Description # CREATE ROLE creates the specified role. The optional WITH ADMIN clause causes the role to be created with the specified user as a role admin. A role admin has permission to drop or grant a role. If the optional WITH ADMIN clause is not specified, the role is created with current user as admin. The optional IN catalog clause creates the role in a catalog as opposed to a system role. Examples # Create role admin CREATE ROLE admin ; Create role moderator with admin bob : CREATE ROLE moderator WITH ADMIN USER bob ; Limitations # Some connectors do not support role management. See connector documentation for more details. See also # DROP ROLE , SET ROLE , GRANT role , REVOKE role Previous CREATE MATERIALIZED VIEW Next CREATE SCHEMA

CREATE SCHEMA — Trino 474 Documentation Skip to content Trino 474 Documentation CREATE SCHEMA  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE SCHEMA Contents Synopsis Description Examples See also CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also CREATE SCHEMA # Synopsis # CREATE SCHEMA [ IF NOT EXISTS ] schema_name [ AUTHORIZATION ( user | USER user | ROLE role ) ] [ WITH ( property_name = expression [, ...] ) ] Description # Create a new, empty schema. A schema is a container that holds tables, views and other database objects. The optional IF NOT EXISTS clause causes the error to be suppressed if the schema already exists. The optional AUTHORIZATION clause can be used to set the owner of the newly created schema to a user or role. The optional WITH clause can be used to set properties on the newly created schema. To list all available schema properties, run the following query: SELECT * FROM system . metadata . schema_properties Examples # Create a new schema web in the current catalog: CREATE SCHEMA web Create a new schema sales in the hive catalog: CREATE SCHEMA hive . sales Create the schema traffic if it does not already exist: CREATE SCHEMA IF NOT EXISTS traffic Create a new schema web and set the owner to user alice : CREATE SCHEMA web AUTHORIZATION alice Create a new schema web , set the LOCATION property to /hive/data/web and set the owner to user alice : CREATE SCHEMA web AUTHORIZATION alice WITH ( LOCATION = '/hive/data/web' ) Create a new schema web and allow everyone to drop schema and create tables in schema web : CREATE SCHEMA web AUTHORIZATION ROLE PUBLIC Create a new schema web , set the LOCATION property to /hive/data/web and allow everyone to drop schema and create tables in schema web : CREATE SCHEMA web AUTHORIZATION ROLE PUBLIC WITH ( LOCATION = '/hive/data/web' ) See also # ALTER SCHEMA , DROP SCHEMA Previous CREATE ROLE Next CREATE TABLE

CREATE TABLE — Trino 474 Documentation Skip to content Trino 474 Documentation CREATE TABLE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE Contents Synopsis Description Examples See also CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also CREATE TABLE # Synopsis # CREATE [ OR REPLACE ] TABLE [ IF NOT EXISTS ] table_name ( { column_name data_type [ NOT NULL ] [ COMMENT comment ] [ WITH ( property_name = expression [, ...] ) ] | LIKE existing_table_name [ { INCLUDING | EXCLUDING } PROPERTIES ] } [, ...] ) [ COMMENT table_comment ] [ WITH ( property_name = expression [, ...] ) ] Description # Create a new, empty table with the specified columns. Use CREATE TABLE AS to create a table with data. The optional OR REPLACE clause causes an existing table with the specified name to be replaced with the new table definition. Support for table replacement varies across connectors. Refer to the connector documentation for details. The optional IF NOT EXISTS clause causes the error to be suppressed if the table already exists. OR REPLACE and IF NOT EXISTS cannot be used together. The optional WITH clause can be used to set properties on the newly created table or on single columns. To list all available table properties, run the following query: SELECT * FROM system . metadata . table_properties To list all available column properties, run the following query: SELECT * FROM system . metadata . column_properties The LIKE clause can be used to include all the column definitions from an existing table in the new table. Multiple LIKE clauses may be specified, which allows copying the columns from multiple tables. If INCLUDING PROPERTIES is specified, all of the table properties are copied to the new table. If the WITH clause specifies the same property name as one of the copied properties, the value from the WITH clause will be used. The default behavior is EXCLUDING PROPERTIES . The INCLUDING PROPERTIES option maybe specified for at most one table. Examples # Create a new table orders : CREATE TABLE orders ( orderkey bigint , orderstatus varchar , totalprice double , orderdate date ) WITH ( format = 'ORC' ) Create the table orders if it does not already exist, adding a table comment and a column comment: CREATE TABLE IF NOT EXISTS orders ( orderkey bigint , orderstatus varchar , totalprice double COMMENT 'Price in cents.' , orderdate date ) COMMENT 'A table to keep track of orders.' Create the table bigger_orders using the columns from orders plus additional columns at the start and end: CREATE TABLE bigger_orders ( another_orderkey bigint , LIKE orders , another_orderdate date ) See also # ALTER TABLE , DROP TABLE , CREATE TABLE AS , SHOW CREATE TABLE Previous CREATE SCHEMA Next CREATE TABLE AS

CREATE TABLE AS — Trino 474 Documentation Skip to content Trino 474 Documentation CREATE TABLE AS  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE TABLE AS Contents Synopsis Description Examples See also CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also CREATE TABLE AS # Synopsis # CREATE [ OR REPLACE ] TABLE [ IF NOT EXISTS ] table_name [ ( column_alias, ... ) ] [ COMMENT table_comment ] [ WITH ( property_name = expression [, ...] ) ] AS query [ WITH [ NO ] DATA ] Description # Create a new table containing the result of a SELECT query. Use CREATE TABLE to create an empty table. The optional OR REPLACE clause causes an existing table with the specified name to be replaced with the new table definition. Support for table replacement varies across connectors. Refer to the connector documentation for details. The optional IF NOT EXISTS clause causes the error to be suppressed if the table already exists. OR REPLACE and IF NOT EXISTS cannot be used together. The optional WITH clause can be used to set properties on the newly created table. To list all available table properties, run the following query: SELECT * FROM system . metadata . table_properties Examples # Create a new table orders_column_aliased with the results of a query and the given column names: CREATE TABLE orders_column_aliased ( order_date , total_price ) AS SELECT orderdate , totalprice FROM orders Create a new table orders_by_date that summarizes orders : CREATE TABLE orders_by_date COMMENT 'Summary of orders by date' WITH ( format = 'ORC' ) AS SELECT orderdate , sum ( totalprice ) AS price FROM orders GROUP BY orderdate Create the table orders_by_date if it does not already exist: CREATE TABLE IF NOT EXISTS orders_by_date AS SELECT orderdate , sum ( totalprice ) AS price FROM orders GROUP BY orderdate Create a new empty_nation table with the same schema as nation and no data: CREATE TABLE empty_nation AS SELECT * FROM nation WITH NO DATA See also # CREATE TABLE , SELECT Previous CREATE TABLE Next CREATE VIEW

CREATE VIEW — Trino 474 Documentation Skip to content Trino 474 Documentation CREATE VIEW  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW CREATE VIEW Contents Synopsis Description Security Examples See also DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Security Examples See also CREATE VIEW # Synopsis # CREATE [ OR REPLACE ] VIEW view_name [ COMMENT view_comment ] [ SECURITY { DEFINER | INVOKER } ] AS query Description # Create a new view of a SELECT query. The view is a logical table that can be referenced by future queries. Views do not contain any data. Instead, the query stored by the view is executed every time the view is referenced by another query. The optional OR REPLACE clause causes the view to be replaced if it already exists rather than raising an error. Security # In the default DEFINER security mode, tables referenced in the view are accessed using the permissions of the view owner (the creator or definer of the view) rather than the user executing the query. This allows providing restricted access to the underlying tables, for which the user may not be allowed to access directly. In the INVOKER security mode, tables referenced in the view are accessed using the permissions of the user executing the query (the invoker of the view). A view created in this mode is simply a stored query. Regardless of the security mode, the current_user function will always return the user executing the query and thus may be used within views to filter out rows or otherwise restrict access. Examples # Create a simple view test over the orders table: CREATE VIEW test AS SELECT orderkey , orderstatus , totalprice / 2 AS half FROM orders Create a view test_with_comment with a view comment: CREATE VIEW test_with_comment COMMENT 'A view to keep track of orders.' AS SELECT orderkey , orderstatus , totalprice FROM orders Create a view orders_by_date that summarizes orders : CREATE VIEW orders_by_date AS SELECT orderdate , sum ( totalprice ) AS price FROM orders GROUP BY orderdate Create a view that replaces an existing view: CREATE OR REPLACE VIEW test AS SELECT orderkey , orderstatus , totalprice / 4 AS quarter FROM orders See also # ALTER VIEW DROP VIEW SHOW CREATE VIEW SHOW TABLES Previous CREATE TABLE AS Next DEALLOCATE PREPARE

DEALLOCATE PREPARE — Trino 474 Documentation Skip to content Trino 474 Documentation DEALLOCATE PREPARE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DEALLOCATE PREPARE Contents Synopsis Description Examples See also DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also DEALLOCATE PREPARE # Synopsis # DEALLOCATE PREPARE statement_name Description # Removes a statement with the name statement_name from the list of prepared statements in a session. Examples # Deallocate a statement with the name my_query : DEALLOCATE PREPARE my_query ; See also # PREPARE , EXECUTE , EXECUTE IMMEDIATE Previous CREATE VIEW Next DELETE

DELETE — Trino 474 Documentation Skip to content Trino 474 Documentation DELETE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DELETE Contents Synopsis Description Examples Limitations DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples Limitations DELETE # Synopsis # DELETE FROM table_name [ WHERE condition ] Description # Delete rows from a table. If the WHERE clause is specified, only the matching rows are deleted. Otherwise, all rows from the table are deleted. Examples # Delete all line items shipped by air: DELETE FROM lineitem WHERE shipmode = 'AIR' ; Delete all line items for low priority orders: DELETE FROM lineitem WHERE orderkey IN ( SELECT orderkey FROM orders WHERE priority = 'LOW' ); Delete all orders: DELETE FROM orders ; Limitations # Some connectors have limited or no support for DELETE . See connector documentation for more details. Previous DEALLOCATE PREPARE Next DENY

DENY — Trino 474 Documentation Skip to content Trino 474 Documentation DENY  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DENY Contents Synopsis Description Examples Limitations See also DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples Limitations See also DENY # Synopsis # DENY ( privilege [, ...] | ( ALL PRIVILEGES ) ) ON ( table_name | TABLE table_name | SCHEMA schema_name) TO ( user | USER user | ROLE role ) Description # Denies the specified privileges to the specified grantee. Deny on a table rejects the specified privilege on all current and future columns of the table. Deny on a schema rejects the specified privilege on all current and future columns of all current and future tables of the schema. Examples # Deny INSERT and SELECT privileges on the table orders to user alice : DENY INSERT , SELECT ON orders TO alice ; Deny DELETE privilege on the schema finance to user bob : DENY DELETE ON SCHEMA finance TO bob ; Deny SELECT privilege on the table orders to everyone: DENY SELECT ON orders TO ROLE PUBLIC ; Limitations # The system access controls as well as the connectors provided by default in Trino have no support for DENY . See also # GRANT privilege , REVOKE privilege , SHOW GRANTS Previous DELETE Next DESCRIBE

DESCRIBE — Trino 474 Documentation Skip to content Trino 474 Documentation DESCRIBE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE Contents Synopsis Description DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description DESCRIBE # Synopsis # DESCRIBE table_name Description # DESCRIBE is an alias for SHOW COLUMNS . Previous DENY Next DESCRIBE INPUT

DESCRIBE INPUT — Trino 474 Documentation Skip to content Trino 474 Documentation DESCRIBE INPUT  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE INPUT Contents Synopsis Description Examples See also DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also DESCRIBE INPUT # Synopsis # DESCRIBE INPUT statement_name Description # Lists the input parameters of a prepared statement along with the position and type of each parameter. Parameter types that cannot be determined will appear as unknown . Examples # Prepare and describe a query with three parameters: PREPARE my_select1 FROM SELECT ? FROM nation WHERE regionkey = ? AND name < ? ; DESCRIBE INPUT my_select1 ; Position | Type -------------------- 0 | unknown 1 | bigint 2 | varchar (3 rows) Prepare and describe a query with no parameters: PREPARE my_select2 FROM SELECT * FROM nation ; DESCRIBE INPUT my_select2 ; Position | Type ----------------- (0 rows) See also # PREPARE Previous DESCRIBE Next DESCRIBE OUTPUT

DESCRIBE OUTPUT — Trino 474 Documentation Skip to content Trino 474 Documentation DESCRIBE OUTPUT  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DESCRIBE OUTPUT Contents Synopsis Description Examples See also DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also DESCRIBE OUTPUT # Synopsis # DESCRIBE OUTPUT statement_name Description # List the output columns of a prepared statement, including the column name (or alias), catalog, schema, table, type, type size in bytes, and a boolean indicating if the column is aliased. Examples # Prepare and describe a query with four output columns: PREPARE my_select1 FROM SELECT * FROM nation ; DESCRIBE OUTPUT my_select1 ; Column Name | Catalog | Schema | Table | Type | Type Size | Aliased -------------+---------+--------+--------+---------+-----------+--------- nationkey | tpch | sf1 | nation | bigint | 8 | false name | tpch | sf1 | nation | varchar | 0 | false regionkey | tpch | sf1 | nation | bigint | 8 | false comment | tpch | sf1 | nation | varchar | 0 | false (4 rows) Prepare and describe a query whose output columns are expressions: PREPARE my_select2 FROM SELECT count ( * ) as my_count , 1 + 2 FROM nation ; DESCRIBE OUTPUT my_select2 ; Column Name | Catalog | Schema | Table | Type | Type Size | Aliased -------------+---------+--------+-------+--------+-----------+--------- my_count | | | | bigint | 8 | true _col1 | | | | bigint | 8 | false (2 rows) Prepare and describe a row count query: PREPARE my_create FROM CREATE TABLE foo AS SELECT * FROM nation ; DESCRIBE OUTPUT my_create ; Column Name | Catalog | Schema | Table | Type | Type Size | Aliased -------------+---------+--------+-------+--------+-----------+--------- rows | | | | bigint | 8 | false (1 row) See also # PREPARE Previous DESCRIBE INPUT Next DROP CATALOG

DROP CATALOG — Trino 474 Documentation Skip to content Trino 474 Documentation DROP CATALOG  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP CATALOG Contents Synopsis Description Examples See also DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also DROP CATALOG # Synopsis # DROP CATALOG catalog_name Description # Drops an existing catalog. Dropping a catalog does not interrupt any running queries that use it, but makes it unavailable to any new queries. Warning Some connectors are known not to release all resources when dropping a catalog that uses such connector. This includes all connectors that can read data from HDFS, S3, GCS, or Azure, which are Hive connector , Iceberg connector , Delta Lake connector , and Hudi connector . Note This command requires the catalog management type to be set to dynamic . Examples # Drop the catalog example : DROP CATALOG example ; See also # CREATE CATALOG Catalog management properties Previous DESCRIBE OUTPUT Next DROP FUNCTION

DROP FUNCTION — Trino 474 Documentation Skip to content Trino 474 Documentation DROP FUNCTION  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP FUNCTION Contents Synopsis Description Examples See also DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also DROP FUNCTION # Synopsis # DROP FUNCTION [ IF EXISTS ] udf_name ( [ [ parameter_name ] data_type [, ...] ] ) Description # Removes a catalog UDF . The value of udf_name must be fully qualified with catalog and schema location of the UDF, unless the default UDF storage catalog and schema are configured. The data_type s must be included for UDFs that use parameters to ensure the UDF with the correct name and parameter signature is removed. The optional IF EXISTS clause causes the error to be suppressed if the function does not exist. Examples # The following example removes the meaning_of_life UDF in the default schema of the example catalog: DROP FUNCTION example . default . meaning_of_life (); If the UDF uses a input parameter, the type must be added: DROP FUNCTION multiply_by_two ( bigint ); If the default catalog and schema for UDF storage is configured, you can use the following more compact syntax: DROP FUNCTION meaning_of_life (); See also # CREATE FUNCTION SHOW CREATE FUNCTION SHOW FUNCTIONS User-defined functions SQL environment properties Previous DROP CATALOG Next DROP MATERIALIZED VIEW

DROP MATERIALIZED VIEW — Trino 474 Documentation Skip to content Trino 474 Documentation DROP MATERIALIZED VIEW  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP MATERIALIZED VIEW Contents Synopsis Description Examples See also DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also DROP MATERIALIZED VIEW # Synopsis # DROP MATERIALIZED VIEW [ IF EXISTS ] view_name Description # Drop an existing materialized view view_name . The optional IF EXISTS clause causes the error to be suppressed if the materialized view does not exist. Examples # Drop the materialized view orders_by_date : DROP MATERIALIZED VIEW orders_by_date ; Drop the materialized view orders_by_date if it exists: DROP MATERIALIZED VIEW IF EXISTS orders_by_date ; See also # CREATE MATERIALIZED VIEW SHOW CREATE MATERIALIZED VIEW REFRESH MATERIALIZED VIEW Previous DROP FUNCTION Next DROP ROLE

DROP ROLE — Trino 474 Documentation Skip to content Trino 474 Documentation DROP ROLE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP ROLE Contents Synopsis Description Examples Limitations See also DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples Limitations See also DROP ROLE # Synopsis # DROP ROLE [ IF EXISTS ] role_name [ IN catalog ] Description # DROP ROLE drops the specified role. For DROP ROLE statement to succeed, the user executing it should possess admin privileges for the given role. The optional IF EXISTS prevents the statement from failing if the role isn’t found. The optional IN catalog clause drops the role in a catalog as opposed to a system role. Examples # Drop role admin DROP ROLE admin ; Limitations # Some connectors do not support role management. See connector documentation for more details. See also # CREATE ROLE , SET ROLE , GRANT role , REVOKE role Previous DROP MATERIALIZED VIEW Next DROP SCHEMA

DROP SCHEMA — Trino 474 Documentation Skip to content Trino 474 Documentation DROP SCHEMA  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP SCHEMA Contents Synopsis Description Examples See also DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also DROP SCHEMA # Synopsis # DROP SCHEMA [ IF EXISTS ] schema_name [ CASCADE | RESTRICT ] Description # Drop an existing schema. The schema must be empty. The optional IF EXISTS clause causes the error to be suppressed if the schema does not exist. Examples # Drop the schema web : DROP SCHEMA web Drop the schema sales if it exists: DROP SCHEMA IF EXISTS sales Drop the schema archive , along with everything it contains: DROP SCHEMA archive CASCADE Drop the schema archive , only if there are no objects contained in the schema: DROP SCHEMA archive RESTRICT See also # ALTER SCHEMA , CREATE SCHEMA Previous DROP ROLE Next DROP TABLE

DROP TABLE — Trino 474 Documentation Skip to content Trino 474 Documentation DROP TABLE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP TABLE Contents Synopsis Description Examples See also DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also DROP TABLE # Synopsis # DROP TABLE [ IF EXISTS ] table_name Description # Drops an existing table. The optional IF EXISTS clause causes the error to be suppressed if the table does not exist. The error is not suppressed if a Trino view with the same name exists. Examples # Drop the table orders_by_date : DROP TABLE orders_by_date Drop the table orders_by_date if it exists: DROP TABLE IF EXISTS orders_by_date See also # ALTER TABLE , CREATE TABLE Previous DROP SCHEMA Next DROP VIEW

DROP VIEW — Trino 474 Documentation Skip to content Trino 474 Documentation DROP VIEW  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW DROP VIEW Contents Synopsis Description Examples See also EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also DROP VIEW # Synopsis # DROP VIEW [ IF EXISTS ] view_name Description # Drop an existing view. The optional IF EXISTS clause causes the error to be suppressed if the view does not exist. Examples # Drop the view orders_by_date : DROP VIEW orders_by_date Drop the view orders_by_date if it exists: DROP VIEW IF EXISTS orders_by_date See also # CREATE VIEW Previous DROP TABLE Next EXECUTE

EXECUTE — Trino 474 Documentation Skip to content Trino 474 Documentation EXECUTE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE Contents Synopsis Description Examples See also EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also EXECUTE # Synopsis # EXECUTE statement_name [ USING parameter1 [ , parameter2, ... ] ] Description # Executes a prepared statement with the name statement_name . Parameter values are defined in the USING clause. Examples # Prepare and execute a query with no parameters: PREPARE my_select1 FROM SELECT name FROM nation ; EXECUTE my_select1 ; Prepare and execute a query with two parameters: PREPARE my_select2 FROM SELECT name FROM nation WHERE regionkey = ? and nationkey < ? ; EXECUTE my_select2 USING 1 , 3 ; This is equivalent to: SELECT name FROM nation WHERE regionkey = 1 AND nationkey < 3 ; See also # PREPARE , DEALLOCATE PREPARE , EXECUTE IMMEDIATE Previous DROP VIEW Next EXECUTE IMMEDIATE

EXECUTE IMMEDIATE — Trino 474 Documentation Skip to content Trino 474 Documentation EXECUTE IMMEDIATE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXECUTE IMMEDIATE Contents Synopsis Description Examples See also EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also EXECUTE IMMEDIATE # Synopsis # EXECUTE IMMEDIATE `statement` [ USING parameter1 [ , parameter2, ... ] ] Description # Executes a statement without the need to prepare or deallocate the statement. Parameter values are defined in the USING clause. Examples # Execute a query with no parameters: EXECUTE IMMEDIATE 'SELECT name FROM nation' ; Execute a query with two parameters: EXECUTE IMMEDIATE 'SELECT name FROM nation WHERE regionkey = ? and nationkey < ?' USING 1 , 3 ; This is equivalent to: PREPARE statement_name FROM SELECT name FROM nation WHERE regionkey = ? and nationkey < ? EXECUTE statement_name USING 1 , 3 DEALLOCATE PREPARE statement_name See also # EXECUTE , PREPARE , DEALLOCATE PREPARE Previous EXECUTE Next EXPLAIN

EXPLAIN — Trino 474 Documentation Skip to content Trino 474 Documentation EXPLAIN  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN Contents Synopsis Description Examples EXPLAIN (TYPE LOGICAL) EXPLAIN (TYPE LOGICAL, FORMAT JSON) EXPLAIN (TYPE DISTRIBUTED) EXPLAIN (TYPE DISTRIBUTED, FORMAT JSON) EXPLAIN (TYPE VALIDATE) EXPLAIN (TYPE IO) See also EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples EXPLAIN (TYPE LOGICAL) EXPLAIN (TYPE LOGICAL, FORMAT JSON) EXPLAIN (TYPE DISTRIBUTED) EXPLAIN (TYPE DISTRIBUTED, FORMAT JSON) EXPLAIN (TYPE VALIDATE) EXPLAIN (TYPE IO) See also EXPLAIN # Synopsis # EXPLAIN [ ( option [, ...] ) ] statement where option can be one of: FORMAT { TEXT | GRAPHVIZ | JSON } TYPE { LOGICAL | DISTRIBUTED | VALIDATE | IO } Description # Show the logical or distributed execution plan of a statement, or validate the statement. The distributed plan is shown by default. Each plan fragment of the distributed plan is executed by a single or multiple Trino nodes. Fragments separation represent the data exchange between Trino nodes. Fragment type specifies how the fragment is executed by Trino nodes and how the data is distributed between fragments: SINGLE Fragment is executed on a single node. HASH Fragment is executed on a fixed number of nodes with the input data distributed using a hash function. ROUND_ROBIN Fragment is executed on a fixed number of nodes with the input data distributed in a round-robin fashion. BROADCAST Fragment is executed on a fixed number of nodes with the input data broadcasted to all nodes. SOURCE Fragment is executed on nodes where input splits are accessed. Examples # EXPLAIN (TYPE LOGICAL) # Process the supplied query statement and create a logical plan in text format: EXPLAIN ( TYPE LOGICAL ) SELECT regionkey , count ( * ) FROM nation GROUP BY 1 ; Query Plan ----------------------------------------------------------------------------------------------------------------- Trino version: version Output[regionkey, _col1] │ Layout: [regionkey:bigint, count:bigint] │ Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?} │ _col1 := count └─ RemoteExchange[GATHER] │ Layout: [regionkey:bigint, count:bigint] │ Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?} └─ Aggregate(FINAL)[regionkey] │ Layout: [regionkey:bigint, count:bigint] │ Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?} │ count := count("count_8") └─ LocalExchange[HASH][$hashvalue] ("regionkey") │ Layout: [regionkey:bigint, count_8:bigint, $hashvalue:bigint] │ Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?} └─ RemoteExchange[REPARTITION][$hashvalue_9] │ Layout: [regionkey:bigint, count_8:bigint, $hashvalue_9:bigint] │ Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?} └─ Project[] │ Layout: [regionkey:bigint, count_8:bigint, $hashvalue_10:bigint] │ Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?} │ $hashvalue_10 := "combine_hash"(bigint '0', COALESCE("$operator$hash_code"("regionkey"), 0)) └─ Aggregate(PARTIAL)[regionkey] │ Layout: [regionkey:bigint, count_8:bigint] │ count_8 := count(*) └─ TableScan[tpch:nation:sf0.01] Layout: [regionkey:bigint] Estimates: {rows: 25 (225B), cpu: 225, memory: 0B, network: 0B} regionkey := tpch:regionkey EXPLAIN (TYPE LOGICAL, FORMAT JSON) # Warning The output format is not guaranteed to be backward compatible across Trino versions. Process the supplied query statement and create a logical plan in JSON format: EXPLAIN ( TYPE LOGICAL , FORMAT JSON ) SELECT regionkey , count ( * ) FROM nation GROUP BY 1 ; { "id" : "9" , "name" : "Output" , "descriptor" : { "columnNames" : "[regionkey, _col1]" }, "outputs" : [ { "symbol" : "regionkey" , "type" : "bigint" }, { "symbol" : "count" , "type" : "bigint" } ], "details" : [ "_col1 := count" ], "estimates" : [ { "outputRowCount" : "NaN" , "outputSizeInBytes" : "NaN" , "cpuCost" : "NaN" , "memoryCost" : "NaN" , "networkCost" : "NaN" } ], "children" : [ { "id" : "145" , "name" : "RemoteExchange" , "descriptor" : { "type" : "GATHER" , "isReplicateNullsAndAny" : "" , "hashColumn" : "" }, "outputs" : [ { "symbol" : "regionkey" , "type" : "bigint" }, { "symbol" : "count" , "type" : "bigint" } ], "details" : [ ], "estimates" : [ { "outputRowCount" : "NaN" , "outputSizeInBytes" : "NaN" , "cpuCost" : "NaN" , "memoryCost" : "NaN" , "networkCost" : "NaN" } ], "children" : [ { "id" : "4" , "name" : "Aggregate" , "descriptor" : { "type" : "FINAL" , "keys" : "[regionkey]" , "hash" : "" }, "outputs" : [ { "symbol" : "regionkey" , "type" : "bigint" }, { "symbol" : "count" , "type" : "bigint" } ], "details" : [ "count := count(\"count_0\")" ], "estimates" : [ { "outputRowCount" : "NaN" , "outputSizeInBytes" : "NaN" , "cpuCost" : "NaN" , "memoryCost" : "NaN" , "networkCost" : "NaN" } ], "children" : [ { "id" : "194" , "name" : "LocalExchange" , "descriptor" : { "partitioning" : "HASH" , "isReplicateNullsAndAny" : "" , "hashColumn" : "[$hashvalue]" , "arguments" : "[\"regionkey\"]" }, "outputs" : [ { "symbol" : "regionkey" , "type" : "bigint" }, { "symbol" : "count_0" , "type" : "bigint" }, { "symbol" : "$hashvalue" , "type" : "bigint" } ], "details" :[], "estimates" : [ { "outputRowCount" : "NaN" , "outputSizeInBytes" : "NaN" , "cpuCost" : "NaN" , "memoryCost" : "NaN" , "networkCost" : "NaN" } ], "children" : [ { "id" : "200" , "name" : "RemoteExchange" , "descriptor" : { "type" : "REPARTITION" , "isReplicateNullsAndAny" : "" , "hashColumn" : "[$hashvalue_1]" }, "outputs" : [ { "symbol" : "regionkey" , "type" : "bigint" }, { "symbol" : "count_0" , "type" : "bigint" }, { "symbol" : "$hashvalue_1" , "type" : "bigint" } ], "details" :[], "estimates" : [ { "outputRowCount" : "NaN" , "outputSizeInBytes" : "NaN" , "cpuCost" : "NaN" , "memoryCost" : "NaN" , "networkCost" : "NaN" } ], "children" : [ { "id" : "226" , "name" : "Project" , "descriptor" : {} "outputs" : [ { "symbol" : "regionkey" , "type" : "bigint" }, { "symbol" : "count_0" , "type" : "bigint" }, { "symbol" : "$hashvalue_2" , "type" : "bigint" } ], "details" : [ "$hashvalue_2 := combine_hash(bigint '0', COALESCE(\"$operator$hash_code\"(\"regionkey\"), 0))" ], "estimates" : [ { "outputRowCount" : "NaN" , "outputSizeInBytes" : "NaN" , "cpuCost" : "NaN" , "memoryCost" : "NaN" , "networkCost" : "NaN" } ], "children" : [ { "id" : "198" , "name" : "Aggregate" , "descriptor" : { "type" : "PARTIAL" , "keys" : "[regionkey]" , "hash" : "" }, "outputs" : [ { "symbol" : "regionkey" , "type" : "bigint" }, { "symbol" : "count_0" , "type" : "bigint" } ], "details" : [ "count_0 := count(*)" ], "estimates" :[], "children" : [ { "id" : "0" , "name" : "TableScan" , "descriptor" : { "table" : "hive:tpch_sf1_orc_part:nation" }, "outputs" : [ { "symbol" : "regionkey" , "type" : "bigint" } ], "details" : [ "regionkey := regionkey:bigint:REGULAR" ], "estimates" : [ { "outputRowCount" : 25 , "outputSizeInBytes" : 225 , "cpuCost" : 225 , "memoryCost" : 0 , "networkCost" : 0 } ], "children" : [] } ] } ] } ] } ] } ] } ] } ] } EXPLAIN (TYPE DISTRIBUTED) # Process the supplied query statement and create a distributed plan in text format. The distributed plan splits the logical plan into stages, and therefore explicitly shows the data exchange between workers: EXPLAIN ( TYPE DISTRIBUTED ) SELECT regionkey , count ( * ) FROM nation GROUP BY 1 ; Query Plan ------------------------------------------------------------------------------------------------------ Trino version: version Fragment 0 [SINGLE] Output layout: [regionkey, count] Output partitioning: SINGLE [] Output[regionkey, _col1] │ Layout: [regionkey:bigint, count:bigint] │ Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?} │ _col1 := count └─ RemoteSource[1] Layout: [regionkey:bigint, count:bigint] Fragment 1 [HASH] Output layout: [regionkey, count] Output partitioning: SINGLE [] Aggregate(FINAL)[regionkey] │ Layout: [regionkey:bigint, count:bigint] │ Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?} │ count := count("count_8") └─ LocalExchange[HASH][$hashvalue] ("regionkey") │ Layout: [regionkey:bigint, count_8:bigint, $hashvalue:bigint] │ Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?} └─ RemoteSource[2] Layout: [regionkey:bigint, count_8:bigint, $hashvalue_9:bigint] Fragment 2 [SOURCE] Output layout: [regionkey, count_8, $hashvalue_10] Output partitioning: HASH [regionkey][$hashvalue_10] Project[] │ Layout: [regionkey:bigint, count_8:bigint, $hashvalue_10:bigint] │ Estimates: {rows: ? (?), cpu: ?, memory: ?, network: ?} │ $hashvalue_10 := "combine_hash"(bigint '0', COALESCE("$operator$hash_code"("regionkey"), 0)) └─ Aggregate(PARTIAL)[regionkey] │ Layout: [regionkey:bigint, count_8:bigint] │ count_8 := count(*) └─ TableScan[tpch:nation:sf0.01, grouped = false] Layout: [regionkey:bigint] Estimates: {rows: 25 (225B), cpu: 225, memory: 0B, network: 0B} regionkey := tpch:regionkey EXPLAIN (TYPE DISTRIBUTED, FORMAT JSON) # Warning The output format is not guaranteed to be backward compatible across Trino versions. Process the supplied query statement and create a distributed plan in JSON format. The distributed plan splits the logical plan into stages, and therefore explicitly shows the data exchange between workers: EXPLAIN ( TYPE DISTRIBUTED , FORMAT JSON ) SELECT regionkey , count ( * ) FROM nation GROUP BY 1 ; { "0" : { "id" : "9" , "name" : "Output" , "descriptor" : { "columnNames" : "[regionkey, _col1]" }, "outputs" : [ { "symbol" : "regionkey" , "type" : "bigint" }, { "symbol" : "count" , "type" : "bigint" } ], "details" : [ "_col1 := count" ], "estimates" : [ { "outputRowCount" : "NaN" , "outputSizeInBytes" : "NaN" , "cpuCost" : "NaN" , "memoryCost" : "NaN" , "networkCost" : "NaN" } ], "children" : [ { "id" : "145" , "name" : "RemoteSource" , "descriptor" : { "sourceFragmentIds" : "[1]" }, "outputs" : [ { "symbol" : "regionkey" , "type" : "bigint" }, { "symbol" : "count" , "type" : "bigint" } ], "details" : [ ], "estimates" : [ ], "children" : [ ] } ] }, "1" : { "id" : "4" , "name" : "Aggregate" , "descriptor" : { "type" : "FINAL" , "keys" : "[regionkey]" , "hash" : "[]" }, "outputs" : [ { "symbol" : "regionkey" , "type" : "bigint" }, { "symbol" : "count" , "type" : "bigint" } ], "details" : [ "count := count(\"count_0\")" ], "estimates" : [ { "outputRowCount" : "NaN" , "outputSizeInBytes" : "NaN" , "cpuCost" : "NaN" , "memoryCost" : "NaN" , "networkCost" : "NaN" } ], "children" : [ { "id" : "194" , "name" : "LocalExchange" , "descriptor" : { "partitioning" : "SINGLE" , "isReplicateNullsAndAny" : "" , "hashColumn" : "[]" , "arguments" : "[]" }, "outputs" : [ { "symbol" : "regionkey" , "type" : "bigint" }, { "symbol" : "count_0" , "type" : "bigint" } ], "details" : [ ], "estimates" : [ { "outputRowCount" : "NaN" , "outputSizeInBytes" : "NaN" , "cpuCost" : "NaN" , "memoryCost" : "NaN" , "networkCost" : "NaN" } ], "children" : [ { "id" : "227" , "name" : "Project" , "descriptor" : { }, "outputs" : [ { "symbol" : "regionkey" , "type" : "bigint" }, { "symbol" : "count_0" , "type" : "bigint" } ], "details" : [ ], "estimates" : [ { "outputRowCount" : "NaN" , "outputSizeInBytes" : "NaN" , "cpuCost" : "NaN" , "memoryCost" : "NaN" , "networkCost" : "NaN" } ], "children" : [ { "id" : "200" , "name" : "RemoteSource" , "descriptor" : { "sourceFragmentIds" : "[2]" }, "outputs" : [ { "symbol" : "regionkey" , "type" : "bigint" }, { "symbol" : "count_0" , "type" : "bigint" }, { "symbol" : "$hashvalue" , "type" : "bigint" } ], "details" : [ ], "estimates" : [ ], "children" : [ ] } ] } ] } ] }, "2" : { "id" : "226" , "name" : "Project" , "descriptor" : { }, "outputs" : [ { "symbol" : "regionkey" , "type" : "bigint" }, { "symbol" : "count_0" , "type" : "bigint" }, { "symbol" : "$hashvalue_1" , "type" : "bigint" } ], "details" : [ "$hashvalue_1 := combine_hash(bigint '0', COALESCE(\"$operator$hash_code\"(\"regionkey\"), 0))" ], "estimates" : [ { "outputRowCount" : "NaN" , "outputSizeInBytes" : "NaN" , "cpuCost" : "NaN" , "memoryCost" : "NaN" , "networkCost" : "NaN" } ], "children" : [ { "id" : "198" , "name" : "Aggregate" , "descriptor" : { "type" : "PARTIAL" , "keys" : "[regionkey]" , "hash" : "[]" }, "outputs" : [ { "symbol" : "regionkey" , "type" : "bigint" }, { "symbol" : "count_0" , "type" : "bigint" } ], "details" : [ "count_0 := count(*)" ], "estimates" : [ ], "children" : [ { "id" : "0" , "name" : "TableScan" , "descriptor" : { "table" : "tpch:tiny:nation" }, "outputs" : [ { "symbol" : "regionkey" , "type" : "bigint" } ], "details" : [ "regionkey := tpch:regionkey" ], "estimates" : [ { "outputRowCount" : 25.0 , "outputSizeInBytes" : 225.0 , "cpuCost" : 225.0 , "memoryCost" : 0.0 , "networkCost" : 0.0 } ], "children" : [ ] } ] } ] } } EXPLAIN (TYPE VALIDATE) # Validate the supplied query statement for syntactical and semantic correctness. Returns true if the statement is valid: EXPLAIN ( TYPE VALIDATE ) SELECT regionkey , count ( * ) FROM nation GROUP BY 1 ; Valid ------- true If the statement is not correct because a syntax error, such as an unknown keyword, is found the error message details the problem: EXPLAIN ( TYPE VALIDATE ) SELET 1 = 0 ; Query 20220929_234840_00001_vjwxj failed: line 1:25: mismatched input 'SELET'. Expecting: 'ALTER', 'ANALYZE', 'CALL', 'COMMENT', 'COMMIT', 'CREATE', 'DEALLOCATE', 'DELETE', 'DENY', 'DESC', 'DESCRIBE', 'DROP', 'EXECUTE', 'EXPLAIN', 'GRANT', 'INSERT', 'MERGE', 'PREPARE', 'REFRESH', 'RESET', 'REVOKE', 'ROLLBACK', 'SET', 'SHOW', 'START', 'TRUNCATE', 'UPDATE', 'USE', <query> Similarly if semantic issues are detected, such as an invalid object name nations instead of nation , the error message returns useful information: EXPLAIN ( TYPE VALIDATE ) SELECT * FROM tpch . tiny . nations ; Query 20220929_235059_00003_vjwxj failed: line 1:15: Table 'tpch.tiny.nations' does not exist SELECT * FROM tpch.tiny.nations EXPLAIN (TYPE IO) # Process the supplied query statement and create a plan with input and output details about the accessed objects in JSON format: EXPLAIN ( TYPE IO , FORMAT JSON ) INSERT INTO test_lineitem SELECT * FROM lineitem WHERE shipdate = '2020-02-01' AND quantity > 10 ; Query Plan ----------------------------------- { inputTableColumnInfos: [ { table: { catalog: "hive", schemaTable: { schema: "tpch", table: "test_orders" } }, columnConstraints: [ { columnName: "orderkey", type: "bigint", domain: { nullsAllowed: false, ranges: [ { low: { value: "1", bound: "EXACTLY" }, high: { value: "1", bound: "EXACTLY" } }, { low: { value: "2", bound: "EXACTLY" }, high: { value: "2", bound: "EXACTLY" } } ] } }, { columnName: "processing", type: "boolean", domain: { nullsAllowed: false, ranges: [ { low: { value: "false", bound: "EXACTLY" }, high: { value: "false", bound: "EXACTLY" } } ] } }, { columnName: "custkey", type: "bigint", domain: { nullsAllowed: false, ranges: [ { low: { bound: "ABOVE" }, high: { value: "10", bound: "EXACTLY" } } ] } } ], estimate: { outputRowCount: 2, outputSizeInBytes: 40, cpuCost: 40, maxMemory: 0, networkCost: 0 } } ], outputTable: { catalog: "hive", schemaTable: { schema: "tpch", table: "test_orders" } }, estimate: { outputRowCount: "NaN", outputSizeInBytes: "NaN", cpuCost: "NaN", maxMemory: "NaN", networkCost: "NaN" } } See also # EXPLAIN ANALYZE Previous EXECUTE IMMEDIATE Next EXPLAIN ANALYZE

EXPLAIN ANALYZE — Trino 474 Documentation Skip to content Trino 474 Documentation EXPLAIN ANALYZE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE EXPLAIN ANALYZE Contents Synopsis Description Examples See also GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also EXPLAIN ANALYZE # Synopsis # EXPLAIN ANALYZE [VERBOSE] statement Description # Execute the statement and show the distributed execution plan of the statement along with the cost of each operation. The VERBOSE option will give more detailed information and low-level statistics; understanding these may require knowledge of Trino internals and implementation details. Note The stats may not be entirely accurate, especially for queries that complete quickly. Examples # In the example below, you can see the CPU time spent in each stage, as well as the relative cost of each plan node in the stage. Note that the relative cost of the plan nodes is based on wall time, which may or may not be correlated to CPU time. For each plan node you can see some additional statistics (e.g: average input per node instance). Such statistics are useful when one wants to detect data anomalies for a query (e.g: skewness). EXPLAIN ANALYZE SELECT count ( * ), clerk FROM orders WHERE orderdate > date '1995-01-01' GROUP BY clerk ; Query Plan ----------------------------------------------------------------------------------------------- Trino version: version Queued: 374.17us, Analysis: 190.96ms, Planning: 179.03ms, Execution: 3.06s Fragment 1 [HASH] CPU: 22.58ms, Scheduled: 96.72ms, Blocked 46.21s (Input: 23.06s, Output: 0.00ns), Input: 1000 rows (37.11kB); per task: avg.: 1000.00 std.dev.: 0.00, Output: 1000 rows (28.32kB) Output layout: [clerk, count] Output partitioning: SINGLE [] Project[] │ Layout: [clerk:varchar(15), count:bigint] │ Estimates: {rows: ? (?), cpu: ?, memory: 0B, network: 0B} │ CPU: 8.00ms (3.51%), Scheduled: 63.00ms (15.11%), Blocked: 0.00ns (0.00%), Output: 1000 rows (28.32kB) │ Input avg.: 15.63 rows, Input std.dev.: 24.36% └─ Aggregate[type = FINAL, keys = [clerk], hash = [$hashvalue]] │ Layout: [clerk:varchar(15), $hashvalue:bigint, count:bigint] │ Estimates: {rows: ? (?), cpu: ?, memory: ?, network: 0B} │ CPU: 8.00ms (3.51%), Scheduled: 22.00ms (5.28%), Blocked: 0.00ns (0.00%), Output: 1000 rows (37.11kB) │ Input avg.: 15.63 rows, Input std.dev.: 24.36% │ count := count("count_0") └─ LocalExchange[partitioning = HASH, hashColumn = [$hashvalue], arguments = ["clerk"]] │ Layout: [clerk:varchar(15), count_0:bigint, $hashvalue:bigint] │ Estimates: {rows: ? (?), cpu: ?, memory: 0B, network: 0B} │ CPU: 2.00ms (0.88%), Scheduled: 4.00ms (0.96%), Blocked: 23.15s (50.10%), Output: 1000 rows (37.11kB) │ Input avg.: 15.63 rows, Input std.dev.: 793.73% └─ RemoteSource[sourceFragmentIds = [2]] Layout: [clerk:varchar(15), count_0:bigint, $hashvalue_1:bigint] CPU: 0.00ns (0.00%), Scheduled: 0.00ns (0.00%), Blocked: 23.06s (49.90%), Output: 1000 rows (37.11kB) Input avg.: 15.63 rows, Input std.dev.: 793.73% Fragment 2 [SOURCE] CPU: 210.60ms, Scheduled: 327.92ms, Blocked 0.00ns (Input: 0.00ns, Output: 0.00ns), Input: 1500000 rows (18.17MB); per task: avg.: 1500000.00 std.dev.: 0.00, Output: 1000 rows (37.11kB) Output layout: [clerk, count_0, $hashvalue_2] Output partitioning: HASH [clerk][$hashvalue_2] Aggregate[type = PARTIAL, keys = [clerk], hash = [$hashvalue_2]] │ Layout: [clerk:varchar(15), $hashvalue_2:bigint, count_0:bigint] │ CPU: 30.00ms (13.16%), Scheduled: 30.00ms (7.19%), Blocked: 0.00ns (0.00%), Output: 1000 rows (37.11kB) │ Input avg.: 818058.00 rows, Input std.dev.: 0.00% │ count_0 := count(*) └─ ScanFilterProject[table = hive:sf1:orders, filterPredicate = ("orderdate" > DATE '1995-01-01')] Layout: [clerk:varchar(15), $hashvalue_2:bigint] Estimates: {rows: 1500000 (41.48MB), cpu: 35.76M, memory: 0B, network: 0B}/{rows: 816424 (22.58MB), cpu: 35.76M, memory: 0B, network: 0B}/{rows: 816424 (22.58MB), cpu: 22.58M, memory: 0B, network: 0B} CPU: 180.00ms (78.95%), Scheduled: 298.00ms (71.46%), Blocked: 0.00ns (0.00%), Output: 818058 rows (12.98MB) Input avg.: 1500000.00 rows, Input std.dev.: 0.00% $hashvalue_2 := combine_hash(bigint '0', COALESCE("$operator$hash_code"("clerk"), 0)) clerk := clerk:varchar(15):REGULAR orderdate := orderdate:date:REGULAR Input: 1500000 rows (18.17MB), Filtered: 45.46%, Physical Input: 4.51MB When the VERBOSE option is used, some operators may report additional information. For example, the window function operator will output the following: EXPLAIN ANALYZE VERBOSE SELECT count ( clerk ) OVER () FROM orders WHERE orderdate > date '1995-01-01' ; Query Plan ----------------------------------------------------------------------------------------------- ... ─ Window[] │ Layout: [clerk:varchar(15), count:bigint] │ CPU: 157.00ms (53.40%), Scheduled: 158.00ms (37.71%), Blocked: 0.00ns (0.00%), Output: 818058 rows (22.62MB) │ metrics: │ 'CPU time distribution (s)' = {count=1.00, p01=0.16, p05=0.16, p10=0.16, p25=0.16, p50=0.16, p75=0.16, p90=0.16, p95=0.16, p99=0.16, min=0.16, max=0.16} │ 'Input rows distribution' = {count=1.00, p01=818058.00, p05=818058.00, p10=818058.00, p25=818058.00, p50=818058.00, p75=818058.00, p90=818058.00, p95=818058.00, p99=818058.00, min=818058.00, max=818058.00} │ 'Scheduled time distribution (s)' = {count=1.00, p01=0.16, p05=0.16, p10=0.16, p25=0.16, p50=0.16, p75=0.16, p90=0.16, p95=0.16, p99=0.16, min=0.16, max=0.16} │ Input avg.: 818058.00 rows, Input std.dev.: 0.00% │ Active Drivers: [ 1 / 1 ] │ Index size: std.dev.: 0.00 bytes, 0.00 rows │ Index count per driver: std.dev.: 0.00 │ Rows per driver: std.dev.: 0.00 │ Size of partition: std.dev.: 0.00 │ count := count("clerk") RANGE UNBOUNDED_PRECEDING CURRENT_ROW ... See also # EXPLAIN Previous EXPLAIN Next GRANT privilege

GRANT privilege — Trino 474 Documentation Skip to content Trino 474 Documentation GRANT privilege  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT privilege Contents Synopsis Description Examples Limitations See also GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples Limitations See also GRANT privilege # Synopsis # GRANT ( privilege [, ...] | ( ALL PRIVILEGES ) ) ON ( table_name | TABLE table_name | SCHEMA schema_name) TO ( user | USER user | ROLE role ) [ WITH GRANT OPTION ] Description # Grants the specified privileges to the specified grantee. Specifying ALL PRIVILEGES grants DELETE , INSERT , UPDATE and SELECT privileges. Specifying ROLE PUBLIC grants privileges to the PUBLIC role and hence to all users. The optional WITH GRANT OPTION clause allows the grantee to grant these same privileges to others. For GRANT statement to succeed, the user executing it should possess the specified privileges as well as the GRANT OPTION for those privileges. Grant on a table grants the specified privilege on all current and future columns of the table. Grant on a schema grants the specified privilege on all current and future columns of all current and future tables of the schema. Examples # Grant INSERT and SELECT privileges on the table orders to user alice : GRANT INSERT , SELECT ON orders TO alice ; Grant DELETE privilege on the schema finance to user bob : GRANT DELETE ON SCHEMA finance TO bob ; Grant SELECT privilege on the table nation to user alice , additionally allowing alice to grant SELECT privilege to others: GRANT SELECT ON nation TO alice WITH GRANT OPTION ; Grant SELECT privilege on the table orders to everyone: GRANT SELECT ON orders TO ROLE PUBLIC ; Limitations # Some connectors have no support for GRANT . See connector documentation for more details. See also # DENY , REVOKE privilege , SHOW GRANTS Previous EXPLAIN ANALYZE Next GRANT role

GRANT role — Trino 474 Documentation Skip to content Trino 474 Documentation GRANT role  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role GRANT role Contents Synopsis Description Examples Limitations See also INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples Limitations See also GRANT role # Synopsis # GRANT role_name [, ...] TO ( user | USER user_name | ROLE role_name) [, ...] [ GRANTED BY ( user | USER user | ROLE role | CURRENT_USER | CURRENT_ROLE ) ] [ WITH ADMIN OPTION ] [ IN catalog ] Description # Grants the specified role(s) to the specified principal(s). If the WITH ADMIN OPTION clause is specified, the role(s) are granted to the users with GRANT option. For the GRANT statement for roles to succeed, the user executing it either should be the role admin or should possess the GRANT option for the given role. The optional GRANTED BY clause causes the role(s) to be granted with the specified principal as a grantor. If the GRANTED BY clause is not specified, the roles are granted with the current user as a grantor. The optional IN catalog clause grants the roles in a catalog as opposed to a system roles. Examples # Grant role bar to user foo GRANT bar TO USER foo ; Grant roles bar and foo to user baz and role qux with admin option GRANT bar , foo TO USER baz , ROLE qux WITH ADMIN OPTION ; Limitations # Some connectors do not support role management. See connector documentation for more details. See also # CREATE ROLE , DROP ROLE , SET ROLE , REVOKE role Previous GRANT privilege Next INSERT

INSERT — Trino 474 Documentation Skip to content Trino 474 Documentation INSERT  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT INSERT Contents Synopsis Description Examples See also MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also INSERT # Synopsis # INSERT INTO table_name [ ( column [, ... ] ) ] query Description # Insert new rows into a table. If the list of column names is specified, they must exactly match the list of columns produced by the query. Each column in the table not present in the column list will be filled with a null value. Otherwise, if the list of columns is not specified, the columns produced by the query must exactly match the columns in the table being inserted into. Examples # Load additional rows into the orders table from the new_orders table: INSERT INTO orders SELECT * FROM new_orders ; Insert a single row into the cities table: INSERT INTO cities VALUES ( 1 , 'San Francisco' ); Insert multiple rows into the cities table: INSERT INTO cities VALUES ( 2 , 'San Jose' ), ( 3 , 'Oakland' ); Insert a single row into the nation table with the specified column list: INSERT INTO nation ( nationkey , name , regionkey , comment ) VALUES ( 26 , 'POLAND' , 3 , 'no comment' ); Insert a row without specifying the comment column. That column will be null : INSERT INTO nation ( nationkey , name , regionkey ) VALUES ( 26 , 'POLAND' , 3 ); See also # VALUES Previous GRANT role Next MATCH_RECOGNIZE

MATCH_RECOGNIZE — Trino 474 Documentation Skip to content Trino 474 Documentation MATCH_RECOGNIZE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MATCH_RECOGNIZE Contents Synopsis Description Example Partitioning and ordering Row pattern measures Rows per match After match skip Row pattern syntax concatenation alternation permutation grouping partition start anchor partition end anchor empty pattern exclusion syntax quantifiers Row pattern union variables Row pattern variable definitions Row pattern recognition expressions pattern variable references classifier function match_number function logical navigation functions physical navigation functions nesting of navigation functions Aggregate functions Aggregation arguments Nesting of aggregate functions Usage of the classifier and match_number functions Row pattern count aggregation RUNNING and FINAL semantics Evaluating expressions in empty matches and unmatched rows MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Example Partitioning and ordering Row pattern measures Rows per match After match skip Row pattern syntax concatenation alternation permutation grouping partition start anchor partition end anchor empty pattern exclusion syntax quantifiers Row pattern union variables Row pattern variable definitions Row pattern recognition expressions pattern variable references classifier function match_number function logical navigation functions physical navigation functions nesting of navigation functions Aggregate functions Aggregation arguments Nesting of aggregate functions Usage of the classifier and match_number functions Row pattern count aggregation RUNNING and FINAL semantics Evaluating expressions in empty matches and unmatched rows MATCH_RECOGNIZE # Synopsis # MATCH_RECOGNIZE ( [ PARTITION BY column [, ...] ] [ ORDER BY column [, ...] ] [ MEASURES measure_definition [, ...] ] [ rows_per_match ] [ AFTER MATCH skip_to ] PATTERN ( row_pattern ) [ SUBSET subset_definition [, ...] ] DEFINE variable_definition [, ...] ) Description # The MATCH_RECOGNIZE clause is an optional subclause of the FROM clause. It is used to detect patterns in a set of rows. Patterns of interest are specified using row pattern syntax based on regular expressions. The input to pattern matching is a table, a view or a subquery. For each detected match, one or more rows are returned. They contain requested information about the match. Row pattern matching is a powerful tool when analyzing complex sequences of events. The following examples show some of the typical use cases: in trade applications, tracking trends or identifying customers with specific behavioral patterns in shipping applications, tracking packages through all possible valid paths, in financial applications, detecting unusual incidents, which might signal fraud Example # In the following example, the pattern describes a V-shape over the totalprice column. A match is found whenever orders made by a customer first decrease in price, and then increase past the starting point: SELECT * FROM orders MATCH_RECOGNIZE ( PARTITION BY custkey ORDER BY orderdate MEASURES A . totalprice AS starting_price , LAST ( B . totalprice ) AS bottom_price , LAST ( U . totalprice ) AS top_price ONE ROW PER MATCH AFTER MATCH SKIP PAST LAST ROW PATTERN ( A B + C + D + ) SUBSET U = ( C , D ) DEFINE B AS totalprice < PREV ( totalprice ), C AS totalprice > PREV ( totalprice ) AND totalprice <= A . totalprice , D AS totalprice > PREV ( totalprice ) ) In the following sections, all subclauses of the MATCH_RECOGNIZE clause are explained with this example query. Partitioning and ordering # PARTITION BY custkey The PARTITION BY clause allows you to break up the input table into separate sections, that are independently processed for pattern matching. Without a partition declaration, the whole input table is used. This behavior is analogous to the semantics of PARTITION BY clause in window specification . In the example, the orders table is partitioned by the custkey value, so that pattern matching is performed for all orders of a specific customer independently from orders of other customers. ORDER BY orderdate The optional ORDER BY clause is generally useful to allow matching on an ordered data set. For example, sorting the input by orderdate allows for matching on a trend of changes over time. Row pattern measures # The MEASURES clause allows to specify what information is retrieved from a matched sequence of rows. MEASURES measure_expression AS measure_name [, ...] A measure expression is a scalar expression whose value is computed based on a match. In the example, three row pattern measures are specified: A.totalprice AS starting_price returns the price in the first row of the match, which is the only row associated with A according to the pattern. LAST(B.totalprice) AS bottom_price returns the lowest price (corresponding to the bottom of the “V” in the pattern). It is the price in the last row associated with B , which is the last row of the descending section. LAST(U.totalprice) AS top_price returns the highest price in the match. It is the price in the last row associated with C or D , which is also the final row of the match. Measure expressions can refer to the columns of the input table. They also allow special syntax to combine the input information with the details of the match (see Row pattern recognition expressions ). Each measure defines an output column of the pattern recognition. The column can be referenced with the measure_name . The MEASURES clause is optional. When no measures are specified, certain input columns (depending on ROWS PER MATCH clause) are the output of the pattern recognition. Rows per match # This clause can be used to specify the quantity of output rows. There are two main options: ONE ROW PER MATCH and ALL ROWS PER MATCH ONE ROW PER MATCH is the default option. For every match, a single row of output is produced. Output consists of PARTITION BY columns and measures. The output is also produced for empty matches, based on their starting rows. Rows that are unmatched (that is, neither included in some non-empty match, nor being the starting row of an empty match), are not included in the output. For ALL ROWS PER MATCH , every row of a match produces an output row, unless it is excluded from the output by the exclusion syntax . Output consists of PARTITION BY columns, ORDER BY columns, measures and remaining columns from the input table. By default, empty matches are shown and unmatched rows are skipped, similarly as with the ONE ROW PER MATCH option. However, this behavior can be changed by modifiers: ALL ROWS PER MATCH SHOW EMPTY MATCHES shows empty matches and skips unmatched rows, like the default. ALL ROWS PER MATCH OMIT EMPTY MATCHES excludes empty matches from the output. ALL ROWS PER MATCH WITH UNMATCHED ROWS shows empty matches and produces additional output row for each unmatched row. There are special rules for computing row pattern measures for empty matches and unmatched rows. They are explained in Evaluating expressions in empty matches and unmatched rows . Unmatched rows can only occur when the pattern does not allow an empty match. Otherwise, they are considered as starting rows of empty matches. The option ALL ROWS PER MATCH WITH UNMATCHED ROWS is recommended when pattern recognition is expected to pass all input rows, and it is not certain whether the pattern allows an empty match. After match skip # The AFTER MATCH SKIP clause specifies where pattern matching resumes after a non-empty match is found. The default option is: AFTER MATCH SKIP PAST LAST ROW With this option, pattern matching starts from the row after the last row of the match. Overlapping matches are not detected. With the following option, pattern matching starts from the second row of the match: AFTER MATCH SKIP TO NEXT ROW In the example, if a V-shape is detected, further overlapping matches are found, starting from consecutive rows on the descending slope of the “V”. Skipping to the next row is the default behavior after detecting an empty match or unmatched row. The following AFTER MATCH SKIP options allow to resume pattern matching based on the components of the pattern. Pattern matching starts from the last (default) or first row matched to a certain row pattern variable. It can be either a primary pattern variable (they are explained in Row pattern syntax ) or a union variable : AFTER MATCH SKIP TO [ FIRST | LAST ] pattern_variable It is forbidden to skip to the first row of the current match, because it results in an infinite loop. For example specifying AFTER MATCH SKIP TO A fails, because A is the first element of the pattern, and jumping back to it creates an infinite loop. Similarly, skipping to a pattern variable which is not present in the match causes failure. All other options than the default AFTER MATCH SKIP PAST LAST ROW allow detection of overlapping matches. The combination of ALL ROWS PER MATCH WITH UNMATCHED ROWS with AFTER MATCH SKIP PAST LAST ROW is the only configuration that guarantees exactly one output row for each input row. Row pattern syntax # Row pattern is a form of a regular expression with some syntactical extensions specific to row pattern recognition. It is specified in the PATTERN clause: PATTERN ( row_pattern ) The basic element of row pattern is a primary pattern variable. Like pattern matching in character strings searches for characters, pattern matching in row sequences searches for rows which can be “labeled” with certain primary pattern variables. A primary pattern variable has a form of an identifier and is defined by a boolean condition. This condition determines whether a particular input row can be mapped to this variable and take part in the match. In the example PATTERN (A B+ C+ D+) , there are four primary pattern variables: A , B , C , and D . Row pattern syntax includes the following usage: concatenation # A B+ C+ D+ It is a sequence of components without operators between them. All components are matched in the same order as they are specified. alternation # A | B | C It is a sequence of components separated by | . Exactly one of the components is matched. In case when multiple components can be matched, the leftmost matching component is chosen. permutation # PERMUTE(A, B, C) It is equivalent to alternation of all permutations of its components. All components are matched in some order. If multiple matches are possible for different orderings of the components, the match is chosen based on the lexicographical order established by the order of components in the PERMUTE list. In the above example, the most preferred option is A B C , and the least preferred option is C B A . grouping # (A B C) partition start anchor # ^ partition end anchor # $ empty pattern # () exclusion syntax # {- row_pattern -} Exclusion syntax is used to specify portions of the match to exclude from the output. It is useful in combination with the ALL ROWS PER MATCH option, when only certain sections of the match are interesting. If you change the example to use ALL ROWS PER MATCH , and the pattern is modified to PATTERN (A {- B+ C+ -} D+) , the result consists of the initial matched row and the trailing section of rows. Specifying pattern exclusions does not affect the computation of expressions in MEASURES and DEFINE clauses. Exclusions also do not affect pattern matching. They have the same semantics as regular grouping with parentheses. It is forbidden to specify pattern exclusions with the option ALL ROWS PER MATCH WITH UNMATCHED ROWS . quantifiers # Pattern quantifiers allow to specify the desired number of repetitions of a sub-pattern in a match. They are appended after the relevant pattern component: ( A | B ) * There are following row pattern quantifiers: zero or more repetitions: * one or more repetitions: + zero or one repetition: ? exact number of repetitions, specified by a non-negative integer number: {n} number of repetitions ranging between bounds, specified by non-negative integer numbers: {m, n} Specifying bounds is optional. If the left bound is omitted, it defaults to 0 . So, {, 5} can be described as “between zero and five repetitions”. If the right bound is omitted, the number of accepted repetitions is unbounded. So, {5, } can be described as “at least five repetitions”. Also, {,} is equivalent to * . Quantifiers are greedy by default. It means that higher number of repetitions is preferred over lower number. This behavior can be changed to reluctant by appending ? immediately after the quantifier. With {3, 5} , 3 repetitions is the least desired option and 5 repetitions – the most desired. With {3, 5}? , 3 repetitions are most desired. Similarly, ? prefers 1 repetition, while ?? prefers 0 repetitions. Row pattern union variables # As explained in Row pattern syntax , primary pattern variables are the basic elements of row pattern. In addition to primary pattern variables, you can define union variables. They are introduced in the SUBSET clause: SUBSET U = ( C , D ), ... In the preceding example, union variable U is defined as union of primary variables C and D . Union variables are useful in MEASURES , DEFINE and AFTER MATCH SKIP clauses. They allow you to refer to set of rows matched to either primary variable from a subset. With the pattern: PATTERN((A | B){5} C+) it cannot be determined upfront if the match contains any A or any B . A union variable can be used to access the last row matched to either A or B . Define SUBSET U = (A, B) , and the expression LAST(U.totalprice) returns the value of the totalprice column from the last row mapped to either A or B . Also, AFTER MATCH SKIP TO LAST A or AFTER MATCH SKIP TO LAST B can result in failure if A or B is not present in the match. AFTER MATCH SKIP TO LAST U does not fail. Row pattern variable definitions # The DEFINE clause is where row pattern primary variables are defined. Each variable is associated with a boolean condition: DEFINE B AS totalprice < PREV ( totalprice ), ... During pattern matching, when a certain variable is considered for the next step of the match, the boolean condition is evaluated in context of the current match. If the result is true , then the current row, “labeled” with the variable, becomes part of the match. In the preceding example, assume that the pattern allows to match B at some point. There are some rows already matched to some pattern variables. Now, variable B is being considered for the current row. Before the match is made, the defining condition for B is evaluated. In this example, it is only true if the value of the totalprice column in the current row is lower than totalprice in the preceding row. The mechanism of matching variables to rows shows the difference between pattern matching in row sequences and regular expression matching in text. In text, characters remain constantly in their positions. In row pattern matching, a row can be mapped to different variables in different matches, depending on the preceding part of the match, and even on the match number. It is not required that every primary variable has a definition in the DEFINE clause. Variables not mentioned in the DEFINE clause are implicitly associated with true condition, which means that they can be matched to every row. Boolean expressions in the DEFINE clause allow the same special syntax as expressions in the MEASURES clause. Details are explained in Row pattern recognition expressions . Row pattern recognition expressions # Expressions in MEASURES and DEFINE clauses are scalar expressions evaluated over rows of the input table. They support special syntax, specific to pattern recognition context. They can combine input information with the information about the current match. Special syntax allows to access pattern variables assigned to rows, browse rows based on how they are matched, and refer to the sequential number of the match. pattern variable references # A . totalprice U . orderdate orderstatus A column name prefixed with a pattern variable refers to values of this column in all rows matched to this variable, or to any variable from the subset in case of union variable. If a column name is not prefixed, it is considered as prefixed with the universal pattern variable , defined as union of all primary pattern variables. In other words, a non-prefixed column name refers to all rows of the current match. It is forbidden to prefix a column name with a table name in the pattern recognition context. classifier function # CLASSIFIER () CLASSIFIER ( A ) CLASSIFIER ( U ) The classifier function returns the primary pattern variable associated with the row. The return type is varchar . The optional argument is a pattern variable. It limits the rows of interest, the same way as with prefixed column references. The classifier function is particularly useful with a union variable as the argument. It allows you to determine which variable from the subset actually matched. match_number function # MATCH_NUMBER () The match_number function returns the sequential number of the match within partition, starting from 1 . Empty matches are assigned sequential numbers as well as non-empty matches. The return type is bigint . logical navigation functions # FIRST ( A . totalprice , 2 ) In the above example, the first function navigates to the first row matched to pattern variable A , and then searches forward until it finds two more occurrences of variable A within the match. The result is the value of the totalprice column in that row. LAST ( A . totalprice , 2 ) In the above example, the last function navigates to the last row matched to pattern variable A , and then searches backwards until it finds two more occurrences of variable A within the match. The result is the value of the totalprice column in that row. With the first and last functions the result is null , if the searched row is not found in the mach. The second argument is optional. The default value is 0 , which means that by default these functions navigate to the first or last row of interest. If specified, the second argument must be a non-negative integer number. physical navigation functions # PREV ( A . totalprice , 2 ) In the above example, the prev function navigates to the last row matched to pattern variable A , and then searches two rows backward. The result is the value of the totalprice column in that row. NEXT ( A . totalprice , 2 ) In the above example, the next function navigates to the last row matched to pattern variable A , and then searches two rows forward. The result is the value of the totalprice column in that row. With the prev and next functions, it is possible to navigate and retrieve values outside the match. If the navigation goes beyond partition bounds, the result is null . The second argument is optional. The default value is 1 , which means that by default these functions navigate to previous or next row. If specified, the second argument must be a non-negative integer number. nesting of navigation functions # It is possible to nest logical navigation functions within physical navigation functions: PREV ( FIRST ( A . totalprice , 3 ), 2 ) In case of nesting, first the logical navigation is performed. It establishes the starting row for the physical navigation. When both navigation operations succeed, the value is retrieved from the designated row. Pattern navigation functions require at least one column reference or classifier function inside of their first argument. The following examples are correct: LAST ( "pattern_variable_" || CLASSIFIER ()) NEXT ( U . totalprice + 10 ) This is incorrect: LAST ( 1 ) It is also required that all column references and all classifier calls inside a pattern navigation function are consistent in referred pattern variables. They must all refer either to the same primary variable, the same union variable, or to the implicit universal pattern variable. The following examples are correct: LAST ( CLASSIFIER () = 'A' OR totalprice > 10 ) /* universal pattern variable */ LAST ( CLASSIFIER ( U ) = 'A' OR U . totalprice > 10 ) /* pattern variable U */ This is incorrect: LAST ( A . totalprice + B . totalprice ) Aggregate functions # It is allowed to use aggregate functions in a row pattern recognition context. Aggregate functions are evaluated over all rows of the current match or over a subset of rows based on the matched pattern variables. The running and final semantics are supported, with running as the default. The following expression returns the average value of the totalprice column for all rows matched to pattern variable A : avg ( A . totalprice ) The following expression returns the average value of the totalprice column for all rows matched to pattern variables from subset U : avg ( U . totalprice ) The following expression returns the average value of the totalprice column for all rows of the match: avg ( totalprice ) Aggregation arguments # In case when the aggregate function has multiple arguments, it is required that all arguments refer consistently to the same set of rows: max_by ( totalprice , tax ) /* aggregate over all rows of the match */ max_by ( CLASSIFIER ( A ), A . tax ) /* aggregate over all rows matched to A */ This is incorrect: max_by ( A . totalprice , tax ) max_by ( A . totalprice , A . tax + B . tax ) If an aggregate argument does not contain any column reference or classifier function, it does not refer to any pattern variable. In such a case other aggregate arguments determine the set of rows to aggregate over. If none of the arguments contains a pattern variable reference, the universal row pattern variable is implicit. This means that the aggregate function applies to all rows of the match: count ( 1 ) /* aggregate over all rows of the match */ min_by ( 1 , 2 ) /* aggregate over all rows of the match */ min_by ( 1 , totalprice ) /* aggregate over all rows of the match */ min_by ( totalprice , 1 ) /* aggregate over all rows of the match */ min_by ( A . totalprice , 1 ) /* aggregate over all rows matched to A */ max_by ( 1 , A . totalprice ) /* aggregate over all rows matched to A */ Nesting of aggregate functions # Aggregate function arguments must not contain pattern navigation functions. Similarly, aggregate functions cannot be nested in pattern navigation functions. Usage of the classifier and match_number functions # It is allowed to use the classifier and match_number functions in aggregate function arguments. The following expression returns an array containing all matched pattern variables: array_agg ( CLASSIFIER ()) This is particularly useful in combination with the option ONE ROW PER MATCH . It allows to get all the components of the match while keeping the output size reduced. Row pattern count aggregation # Like other aggregate functions in a row pattern recognition context, the count function can be applied to all rows of the match, or to rows associated with certain row pattern variables: count ( * ), count () /* count all rows of the match */ count ( totalprice ) /* count non-null values of the totalprice column in all rows of the match */ count ( A . totalprice ) /* count non-null values of the totalprice column in all rows matched to A */ The count function in a row pattern recognition context allows special syntax to support the count(*) behavior over a limited set of rows: count ( A . * ) /* count rows matched to A */ count ( U . * ) /* count rows matched to pattern variables from subset U */ RUNNING and FINAL semantics # During pattern matching in a sequence of rows, one row after another is examined to determine if it fits the pattern. At any step, a partial match is known, but it is not yet known what rows will be added in the future or what pattern variables they will be mapped to. So, when evaluating a boolean condition in the DEFINE clause for the current row, only the preceding part of the match (plus the current row) is “visible”. This is the running semantics. When evaluating expressions in the MEASURES clause, the match is complete. It is then possible to apply the final semantics. In the final semantics, the whole match is “visible” as from the position of the final row. In the MEASURES clause, the running semantics can also be applied. When outputting information row by row (as in ALL ROWS PER MATCH ), the running semantics evaluate expressions from the positions of consecutive rows. The running and final semantics are denoted by the keywords: RUNNING and FINAL , preceding a logical navigation function first or last , or an aggregate function: RUNNING LAST ( A . totalprice ) FINAL LAST ( A . totalprice ) RUNNING avg ( A . totalprice ) FINAL count ( A . * ) The running semantics is default in MEASURES and DEFINE clauses. FINAL can only be specified in the MEASURES clause. With the option ONE ROW PER MATCH , row pattern measures are evaluated from the position of the final row in the match. Therefore, running and final semantics are the same. Evaluating expressions in empty matches and unmatched rows # An empty match occurs when the row pattern is successfully matched, but no pattern variables are assigned. The following pattern produces an empty match for every row: PATTERN (()) When evaluating row pattern measures for an empty match: all column references return null all navigation operations return null classifier function returns null match_number function returns the sequential number of the match all aggregate functions are evaluated over an empty set of rows Like every match, an empty match has its starting row. All input values which are to be output along with the measures (as explained in Rows per match ), are the values from the starting row. An unmatched row is a row that is neither part of any non-empty match nor the starting row of an empty match. With the option ALL ROWS PER MATCH WITH UNMATCHED ROWS , a single output row is produced. In that row, all row pattern measures are null . All input values which are to be output along with the measures (as explained in Rows per match ), are the values from the unmatched row. Using the match_number function as a measure can help differentiate between an empty match and unmatched row. Previous INSERT Next MERGE

MERGE — Trino 474 Documentation Skip to content Trino 474 Documentation MERGE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE MERGE Contents Synopsis Description Examples Limitations PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples Limitations MERGE # Synopsis # MERGE INTO target_table [ [ AS ] target_alias ] USING { source_table | query } [ [ AS ] source_alias ] ON search_condition when_clause [...] where when_clause is one of WHEN MATCHED [ AND condition ] THEN DELETE WHEN MATCHED [ AND condition ] THEN UPDATE SET ( column = expression [, ...] ) WHEN NOT MATCHED [ AND condition ] THEN INSERT [ column_list ] VALUES (expression, ...) Description # Conditionally update and/or delete rows of a table and/or insert new rows into a table. MERGE changes data in the target_table based on the contents of the source_table . The search_condition defines a condition, such as a relation from identical columns, to associate the source and target data. MERGE supports an arbitrary number of WHEN clauses. MATCHED conditions can execute DELETE or UPDATE operations on the target data, while NOT MATCHED conditions can add data from the source to the target table with INSERT . Additional conditions can narrow down the affected rows. For each source row, the WHEN clauses are processed in order. Only the first matching WHEN clause is executed and subsequent clauses are ignored. The query fails if a single target table row matches more than one source row. In WHEN clauses with UPDATE operations, the column value expressions can depend on any field of the target or the source. In the NOT MATCHED case, the INSERT expressions can depend on any field of the source. Typical usage of MERGE involves two tables with similar structure, containing different data. For example, the source table is part of a transactional usage in a production system, while the target table is located in a data warehouse used for analytics. Periodically, MERGE operations are run to combine recent production data with long-term data in the analytics warehouse. As long as you can define a search condition between the two tables, you can also use very different tables. Examples # Delete all customers mentioned in the source table: MERGE INTO accounts t USING monthly_accounts_update s ON t . customer = s . customer WHEN MATCHED THEN DELETE For matching customer rows, increment the purchases, and if there is no match, insert the row from the source table: MERGE INTO accounts t USING monthly_accounts_update s ON ( t . customer = s . customer ) WHEN MATCHED THEN UPDATE SET purchases = s . purchases + t . purchases WHEN NOT MATCHED THEN INSERT ( customer , purchases , address ) VALUES ( s . customer , s . purchases , s . address ) MERGE into the target table from the source table, deleting any matching target row for which the source address is Centreville . For all other matching rows, add the source purchases and set the address to the source address. If there is no match in the target table, insert the source table row: MERGE INTO accounts t USING monthly_accounts_update s ON ( t . customer = s . customer ) WHEN MATCHED AND s . address = 'Centreville' THEN DELETE WHEN MATCHED THEN UPDATE SET purchases = s . purchases + t . purchases , address = s . address WHEN NOT MATCHED THEN INSERT ( customer , purchases , address ) VALUES ( s . customer , s . purchases , s . address ) Limitations # Any connector can be used as a source table for a MERGE statement. Only connectors which support the MERGE statement can be the target of a merge operation. See the connector documentation for more information. Previous MATCH_RECOGNIZE Next PREPARE

PREPARE — Trino 474 Documentation Skip to content Trino 474 Documentation PREPARE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE PREPARE Contents Synopsis Description Examples See also REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also PREPARE # Synopsis # PREPARE statement_name FROM statement Description # Prepares a statement for execution at a later time. Prepared statements are queries that are saved in a session with a given name. The statement can include parameters in place of literals to be replaced at execution time. Parameters are represented by question marks. Examples # Prepare a select query: PREPARE my_select1 FROM SELECT * FROM nation ; Prepare a select query that includes parameters. The values to compare with regionkey and nationkey will be filled in with the EXECUTE statement: PREPARE my_select2 FROM SELECT name FROM nation WHERE regionkey = ? AND nationkey < ? ; Prepare an insert query: PREPARE my_insert FROM INSERT INTO cities VALUES ( 1 , 'San Francisco' ); See also # EXECUTE , DEALLOCATE PREPARE , EXECUTE IMMEDIATE , DESCRIBE INPUT , DESCRIBE OUTPUT Previous MERGE Next REFRESH MATERIALIZED VIEW

REFRESH MATERIALIZED VIEW — Trino 474 Documentation Skip to content Trino 474 Documentation REFRESH MATERIALIZED VIEW  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW REFRESH MATERIALIZED VIEW Contents Synopsis Description See also RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description See also REFRESH MATERIALIZED VIEW # Synopsis # REFRESH MATERIALIZED VIEW view_name Description # Initially populate or refresh the data stored in the materialized view view_name . The materialized view must be defined with CREATE MATERIALIZED VIEW . Data is retrieved from the underlying tables accessed by the defined query. The initial population of the materialized view is typically processing intensive since it reads the data from the source tables and performs physical write operations. The refresh operation can be less intensive, if the underlying data has not changed and the connector has implemented a mechanism to be aware of that. The specific implementation and performance varies by connector used to create the materialized view. See also # CREATE MATERIALIZED VIEW DROP MATERIALIZED VIEW SHOW CREATE MATERIALIZED VIEW Previous PREPARE Next RESET SESSION

RESET SESSION — Trino 474 Documentation Skip to content Trino 474 Documentation RESET SESSION  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION Contents Synopsis Description Examples See also RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also RESET SESSION # Synopsis # RESET SESSION name RESET SESSION catalog.name Description # Reset a session property value to the default value. Examples # RESET SESSION query_max_run_time ; RESET SESSION hive . optimized_reader_enabled ; See also # SET SESSION , SHOW SESSION Previous REFRESH MATERIALIZED VIEW Next RESET SESSION AUTHORIZATION

RESET SESSION AUTHORIZATION — Trino 474 Documentation Skip to content Trino 474 Documentation RESET SESSION AUTHORIZATION  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION RESET SESSION AUTHORIZATION Contents Synopsis Description See also REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description See also RESET SESSION AUTHORIZATION # Synopsis # RESET SESSION AUTHORIZATION Description # Resets the current authorization user back to the original user. The original user is usually the authenticated user (principal), or it can be the session user when the session user is provided by the client. See also # SET SESSION AUTHORIZATION Previous RESET SESSION Next REVOKE privilege

REVOKE privilege — Trino 474 Documentation Skip to content Trino 474 Documentation REVOKE privilege  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE privilege Contents Synopsis Description Examples Limitations See also REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples Limitations See also REVOKE privilege # Synopsis # REVOKE [ GRANT OPTION FOR ] ( privilege [, ...] | ALL PRIVILEGES ) ON ( table_name | TABLE table_name | SCHEMA schema_name ) FROM ( user | USER user | ROLE role ) Description # Revokes the specified privileges from the specified grantee. Specifying ALL PRIVILEGES revokes DELETE , INSERT and SELECT privileges. Specifying ROLE PUBLIC revokes privileges from the PUBLIC role. Users will retain privileges assigned to them directly or via other roles. If the optional GRANT OPTION FOR clause is specified, only the GRANT OPTION is removed. Otherwise, both the GRANT and GRANT OPTION are revoked. For REVOKE statement to succeed, the user executing it should possess the specified privileges as well as the GRANT OPTION for those privileges. Revoke on a table revokes the specified privilege on all columns of the table. Revoke on a schema revokes the specified privilege on all columns of all tables of the schema. Examples # Revoke INSERT and SELECT privileges on the table orders from user alice : REVOKE INSERT , SELECT ON orders FROM alice ; Revoke DELETE privilege on the schema finance from user bob : REVOKE DELETE ON SCHEMA finance FROM bob ; Revoke SELECT privilege on the table nation from everyone, additionally revoking the privilege to grant SELECT privilege: REVOKE GRANT OPTION FOR SELECT ON nation FROM ROLE PUBLIC ; Revoke all privileges on the table test from user alice : REVOKE ALL PRIVILEGES ON test FROM alice ; Limitations # Some connectors have no support for REVOKE . See connector documentation for more details. See also # DENY , GRANT privilege , SHOW GRANTS Previous RESET SESSION AUTHORIZATION Next REVOKE role

REVOKE role — Trino 474 Documentation Skip to content Trino 474 Documentation REVOKE role  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role REVOKE role Contents Synopsis Description Examples Limitations See also ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples Limitations See also REVOKE role # Synopsis # REVOKE [ ADMIN OPTION FOR ] role_name [, ...] FROM ( user | USER user | ROLE role) [, ...] [ GRANTED BY ( user | USER user | ROLE role | CURRENT_USER | CURRENT_ROLE ) ] [ IN catalog ] Description # Revokes the specified role(s) from the specified principal(s). If the ADMIN OPTION FOR clause is specified, the GRANT permission is revoked instead of the role. For the REVOKE statement for roles to succeed, the user executing it either should be the role admin or should possess the GRANT option for the given role. The optional GRANTED BY clause causes the role(s) to be revoked with the specified principal as a revoker. If the GRANTED BY clause is not specified, the roles are revoked by the current user as a revoker. The optional IN catalog clause revokes the roles in a catalog as opposed to a system roles. Examples # Revoke role bar from user foo REVOKE bar FROM USER foo ; Revoke admin option for roles bar and foo from user baz and role qux REVOKE ADMIN OPTION FOR bar , foo FROM USER baz , ROLE qux ; Limitations # Some connectors do not support role management. See connector documentation for more details. See also # CREATE ROLE , DROP ROLE , SET ROLE , GRANT role Previous REVOKE privilege Next ROLLBACK

ROLLBACK — Trino 474 Documentation Skip to content Trino 474 Documentation ROLLBACK  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK ROLLBACK Contents Synopsis Description Examples See also SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also ROLLBACK # Synopsis # ROLLBACK [ WORK ] Description # Rollback the current transaction. Examples # ROLLBACK ; ROLLBACK WORK ; See also # COMMIT , START TRANSACTION Previous REVOKE role Next SELECT

SELECT — Trino 474 Documentation Skip to content Trino 474 Documentation SELECT  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SELECT Contents Synopsis Description WITH SESSION clause WITH FUNCTION clause WITH clause WITH RECURSIVE clause SELECT clause Select expressions GROUP BY clause Complex grouping operations GROUPING SETS CUBE ROLLUP Combining multiple grouping expressions GROUPING operation HAVING clause WINDOW clause Set operations UNION clause INTERSECT clause EXCEPT clause ORDER BY clause OFFSET clause LIMIT or FETCH FIRST clause TABLESAMPLE UNNEST JSON_TABLE Joins CROSS JOIN LATERAL Qualifying column names Subqueries EXISTS IN Scalar subquery SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description WITH SESSION clause WITH FUNCTION clause WITH clause WITH RECURSIVE clause SELECT clause Select expressions GROUP BY clause Complex grouping operations GROUPING SETS CUBE ROLLUP Combining multiple grouping expressions GROUPING operation HAVING clause WINDOW clause Set operations UNION clause INTERSECT clause EXCEPT clause ORDER BY clause OFFSET clause LIMIT or FETCH FIRST clause TABLESAMPLE UNNEST JSON_TABLE Joins CROSS JOIN LATERAL Qualifying column names Subqueries EXISTS IN Scalar subquery SELECT # Synopsis # [ WITH SESSION [ name = expression [, ...] ] [ WITH [ FUNCTION udf ] [, ...] ] [ WITH [ RECURSIVE ] with_query [, ...] ] SELECT [ ALL | DISTINCT ] select_expression [, ...] [ FROM from_item [, ...] ] [ WHERE condition ] [ GROUP BY [ ALL | DISTINCT ] grouping_element [, ...] ] [ HAVING condition] [ WINDOW window_definition_list] [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] select ] [ ORDER BY expression [ ASC | DESC ] [, ...] ] [ OFFSET count [ ROW | ROWS ] ] [ LIMIT { count | ALL } ] [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } { ONLY | WITH TIES } ] where from_item is one of table_name [ [ AS ] alias [ ( column_alias [, ...] ) ] ] from_item join_type from_item [ ON join_condition | USING ( join_column [, ...] ) ] table_name [ [ AS ] alias [ ( column_alias [, ...] ) ] ] MATCH_RECOGNIZE pattern_recognition_specification [ [ AS ] alias [ ( column_alias [, ...] ) ] ] For detailed description of MATCH_RECOGNIZE clause, see pattern recognition in FROM clause . TABLE (table_function_invocation) [ [ AS ] alias [ ( column_alias [, ...] ) ] ] For description of table functions usage, see table functions . and join_type is one of [ INNER ] JOIN LEFT [ OUTER ] JOIN RIGHT [ OUTER ] JOIN FULL [ OUTER ] JOIN CROSS JOIN and grouping_element is one of () expression GROUPING SETS ( ( column [, ...] ) [, ...] ) CUBE ( column [, ...] ) ROLLUP ( column [, ...] ) Description # Retrieve rows from zero or more tables. WITH SESSION clause # The WITH SESSION clause allows you to set session and catalog session property values applicable for the processing of the current SELECT statement only. The defined values override any other configuration and session property settings. Multiple properties are separated by commas. The following example overrides the global configuration property query.max-execution-time with the session property query_max_execution_time to reduce the time to 2h . It also overrides the catalog property iceberg.query-partition-filter-required from the example catalog using Iceberg connector setting the catalog session property query_partition_filter_required to true : WITH SESSION query_max_execution_time = '2h' , example . query_partition_filter_required = true SELECT * FROM example . default . thetable LIMIT 100 ; WITH FUNCTION clause # The WITH FUNCTION clause allows you to define a list of Inline user-defined functions that are available for use in the rest of the query. The following example declares and uses two inline UDFs: WITH FUNCTION hello ( name varchar ) RETURNS varchar RETURN format ( 'Hello %s!' , 'name' ), FUNCTION bye ( name varchar ) RETURNS varchar RETURN format ( 'Bye %s!' , 'name' ) SELECT hello ( 'Finn' ) || ' and ' || bye ( 'Joe' ); -- Hello Finn! and Bye Joe! Find further information about UDFs in general, inline UDFs, all supported statements, and examples in User-defined functions . WITH clause # The WITH clause defines named relations for use within a query. It allows flattening nested queries or simplifying subqueries. For example, the following queries are equivalent: SELECT a , b FROM ( SELECT a , MAX ( b ) AS b FROM t GROUP BY a ) AS x ; WITH x AS ( SELECT a , MAX ( b ) AS b FROM t GROUP BY a ) SELECT a , b FROM x ; This also works with multiple subqueries: WITH t1 AS ( SELECT a , MAX ( b ) AS b FROM x GROUP BY a ), t2 AS ( SELECT a , AVG ( d ) AS d FROM y GROUP BY a ) SELECT t1 . * , t2 . * FROM t1 JOIN t2 ON t1 . a = t2 . a ; Additionally, the relations within a WITH clause can chain: WITH x AS ( SELECT a FROM t ), y AS ( SELECT a AS b FROM x ), z AS ( SELECT b AS c FROM y ) SELECT c FROM z ; Warning Currently, the SQL for the WITH clause will be inlined anywhere the named relation is used. This means that if the relation is used more than once and the query is non-deterministic, the results may be different each time. WITH RECURSIVE clause # The WITH RECURSIVE clause is a variant of the WITH clause. It defines a list of queries to process, including recursive processing of suitable queries. Warning This feature is experimental only. Proceed to use it only if you understand potential query failures and the impact of the recursion processing on your workload. A recursive WITH -query must be shaped as a UNION of two relations. The first relation is called the recursion base , and the second relation is called the recursion step . Trino supports recursive WITH -queries with a single recursive reference to a WITH -query from within the query. The name T of the query T can be mentioned once in the FROM clause of the recursion step relation. The following listing shows a simple example, that displays a commonly used form of a single query in the list: WITH RECURSIVE t(n) AS ( VALUES (1) UNION ALL SELECT n + 1 FROM t WHERE n < 4 ) SELECT sum(n) FROM t; In the preceding query the simple assignment VALUES (1) defines the recursion base relation. SELECT n + 1 FROM t WHERE n < 4 defines the recursion step relation. The recursion processing performs these steps: recursive base yields 1 first recursion yields 1 + 1 = 2 second recursion uses the result from the first and adds one: 2 + 1 = 3 third recursion uses the result from the second and adds one again: 3 + 1 = 4 fourth recursion aborts since n = 4 this results in t having values 1 , 2 , 3 and 4 the final statement performs the sum operation of these elements with the final result value 10 The types of the returned columns are those of the base relation. Therefore it is required that types in the step relation can be coerced to base relation types. The RECURSIVE clause applies to all queries in the WITH list, but not all of them must be recursive. If a WITH -query is not shaped according to the rules mentioned above or it does not contain a recursive reference, it is processed like a regular WITH -query. Column aliases are mandatory for all the queries in the recursive WITH list. The following limitations apply as a result of following the SQL standard and due to implementation choices, in addition to WITH clause limitations: only single-element recursive cycles are supported. Like in regular WITH -queries, references to previous queries in the WITH list are allowed. References to following queries are forbidden. usage of outer joins, set operations, limit clause, and others is not always allowed in the step relation recursion depth is fixed, defaults to 10 , and doesn’t depend on the actual query results You can adjust the recursion depth with the session property max_recursion_depth . When changing the value consider that the size of the query plan growth is quadratic with the recursion depth. SELECT clause # The SELECT clause specifies the output of the query. Each select_expression defines a column or columns to be included in the result. SELECT [ ALL | DISTINCT ] select_expression [, ...] The ALL and DISTINCT quantifiers determine whether duplicate rows are included in the result set. If the argument ALL is specified, all rows are included. If the argument DISTINCT is specified, only unique rows are included in the result set. In this case, each output column must be of a type that allows comparison. If neither argument is specified, the behavior defaults to ALL . Select expressions # Each select_expression must be in one of the following forms: expression [ [ AS ] column_alias ] row_expression.* [ AS ( column_alias [, ...] ) ] relation.* * In the case of expression [ [ AS ] column_alias ] , a single output column is defined. In the case of row_expression.* [ AS ( column_alias [, ...] ) ] , the row_expression is an arbitrary expression of type ROW . All fields of the row define output columns to be included in the result set. In the case of relation.* , all columns of relation are included in the result set. In this case column aliases are not allowed. In the case of * , all columns of the relation defined by the query are included in the result set. In the result set, the order of columns is the same as the order of their specification by the select expressions. If a select expression returns multiple columns, they are ordered the same way they were ordered in the source relation or row type expression. If column aliases are specified, they override any preexisting column or row field names: SELECT ( CAST ( ROW ( 1 , true ) AS ROW ( field1 bigint , field2 boolean ))). * AS ( alias1 , alias2 ); alias1 | alias2 --------+-------- 1 | true (1 row) Otherwise, the existing names are used: SELECT ( CAST ( ROW ( 1 , true ) AS ROW ( field1 bigint , field2 boolean ))). * ; field1 | field2 --------+-------- 1 | true (1 row) and in their absence, anonymous columns are produced: SELECT ( ROW ( 1 , true )). * ; _col0 | _col1 -------+------- 1 | true (1 row) GROUP BY clause # The GROUP BY clause divides the output of a SELECT statement into groups of rows containing matching values. A simple GROUP BY clause may contain any expression composed of input columns or it may be an ordinal number selecting an output column by position (starting at one). The following queries are equivalent. They both group the output by the nationkey input column with the first query using the ordinal position of the output column and the second query using the input column name: SELECT count ( * ), nationkey FROM customer GROUP BY 2 ; SELECT count ( * ), nationkey FROM customer GROUP BY nationkey ; GROUP BY clauses can group output by input column names not appearing in the output of a select statement. For example, the following query generates row counts for the customer table using the input column mktsegment : SELECT count ( * ) FROM customer GROUP BY mktsegment ; _col0 ------- 29968 30142 30189 29949 29752 (5 rows) When a GROUP BY clause is used in a SELECT statement all output expressions must be either aggregate functions or columns present in the GROUP BY clause. Complex grouping operations # Trino also supports complex aggregations using the GROUPING SETS , CUBE and ROLLUP syntax. This syntax allows users to perform analysis that requires aggregation on multiple sets of columns in a single query. Complex grouping operations do not support grouping on expressions composed of input columns. Only column names are allowed. Complex grouping operations are often equivalent to a UNION ALL of simple GROUP BY expressions, as shown in the following examples. This equivalence does not apply, however, when the source of data for the aggregation is non-deterministic. GROUPING SETS # Grouping sets allow users to specify multiple lists of columns to group on. The columns not part of a given sublist of grouping columns are set to NULL . SELECT * FROM shipping ; origin_state | origin_zip | destination_state | destination_zip | package_weight --------------+------------+-------------------+-----------------+---------------- California | 94131 | New Jersey | 8648 | 13 California | 94131 | New Jersey | 8540 | 42 New Jersey | 7081 | Connecticut | 6708 | 225 California | 90210 | Connecticut | 6927 | 1337 California | 94131 | Colorado | 80302 | 5 New York | 10002 | New Jersey | 8540 | 3 (6 rows) GROUPING SETS semantics are demonstrated by this example query: SELECT origin_state , origin_zip , destination_state , sum ( package_weight ) FROM shipping GROUP BY GROUPING SETS ( ( origin_state ), ( origin_state , origin_zip ), ( destination_state )); origin_state | origin_zip | destination_state | _col0 --------------+------------+-------------------+------- New Jersey | NULL | NULL | 225 California | NULL | NULL | 1397 New York | NULL | NULL | 3 California | 90210 | NULL | 1337 California | 94131 | NULL | 60 New Jersey | 7081 | NULL | 225 New York | 10002 | NULL | 3 NULL | NULL | Colorado | 5 NULL | NULL | New Jersey | 58 NULL | NULL | Connecticut | 1562 (10 rows) The preceding query may be considered logically equivalent to a UNION ALL of multiple GROUP BY queries: SELECT origin_state , NULL , NULL , sum ( package_weight ) FROM shipping GROUP BY origin_state UNION ALL SELECT origin_state , origin_zip , NULL , sum ( package_weight ) FROM shipping GROUP BY origin_state , origin_zip UNION ALL SELECT NULL , NULL , destination_state , sum ( package_weight ) FROM shipping GROUP BY destination_state ; However, the query with the complex grouping syntax ( GROUPING SETS , CUBE or ROLLUP ) will only read from the underlying data source once, while the query with the UNION ALL reads the underlying data three times. This is why queries with a UNION ALL may produce inconsistent results when the data source is not deterministic. CUBE # The CUBE operator generates all possible grouping sets (i.e. a power set) for a given set of columns. For example, the query: SELECT origin_state , destination_state , sum ( package_weight ) FROM shipping GROUP BY CUBE ( origin_state , destination_state ); is equivalent to: SELECT origin_state , destination_state , sum ( package_weight ) FROM shipping GROUP BY GROUPING SETS ( ( origin_state , destination_state ), ( origin_state ), ( destination_state ), () ); origin_state | destination_state | _col0 --------------+-------------------+------- California | New Jersey | 55 California | Colorado | 5 New York | New Jersey | 3 New Jersey | Connecticut | 225 California | Connecticut | 1337 California | NULL | 1397 New York | NULL | 3 New Jersey | NULL | 225 NULL | New Jersey | 58 NULL | Connecticut | 1562 NULL | Colorado | 5 NULL | NULL | 1625 (12 rows) ROLLUP # The ROLLUP operator generates all possible subtotals for a given set of columns. For example, the query: SELECT origin_state , origin_zip , sum ( package_weight ) FROM shipping GROUP BY ROLLUP ( origin_state , origin_zip ); origin_state | origin_zip | _col2 --------------+------------+------- California | 94131 | 60 California | 90210 | 1337 New Jersey | 7081 | 225 New York | 10002 | 3 California | NULL | 1397 New York | NULL | 3 New Jersey | NULL | 225 NULL | NULL | 1625 (8 rows) is equivalent to: SELECT origin_state , origin_zip , sum ( package_weight ) FROM shipping GROUP BY GROUPING SETS (( origin_state , origin_zip ), ( origin_state ), ()); Combining multiple grouping expressions # Multiple grouping expressions in the same query are interpreted as having cross-product semantics. For example, the following query: SELECT origin_state , destination_state , origin_zip , sum ( package_weight ) FROM shipping GROUP BY GROUPING SETS (( origin_state , destination_state )), ROLLUP ( origin_zip ); which can be rewritten as: SELECT origin_state , destination_state , origin_zip , sum ( package_weight ) FROM shipping GROUP BY GROUPING SETS (( origin_state , destination_state )), GROUPING SETS (( origin_zip ), ()); is logically equivalent to: SELECT origin_state , destination_state , origin_zip , sum ( package_weight ) FROM shipping GROUP BY GROUPING SETS ( ( origin_state , destination_state , origin_zip ), ( origin_state , destination_state ) ); origin_state | destination_state | origin_zip | _col3 --------------+-------------------+------------+------- New York | New Jersey | 10002 | 3 California | New Jersey | 94131 | 55 New Jersey | Connecticut | 7081 | 225 California | Connecticut | 90210 | 1337 California | Colorado | 94131 | 5 New York | New Jersey | NULL | 3 New Jersey | Connecticut | NULL | 225 California | Colorado | NULL | 5 California | Connecticut | NULL | 1337 California | New Jersey | NULL | 55 (10 rows) The ALL and DISTINCT quantifiers determine whether duplicate grouping sets each produce distinct output rows. This is particularly useful when multiple complex grouping sets are combined in the same query. For example, the following query: SELECT origin_state , destination_state , origin_zip , sum ( package_weight ) FROM shipping GROUP BY ALL CUBE ( origin_state , destination_state ), ROLLUP ( origin_state , origin_zip ); is equivalent to: SELECT origin_state , destination_state , origin_zip , sum ( package_weight ) FROM shipping GROUP BY GROUPING SETS ( ( origin_state , destination_state , origin_zip ), ( origin_state , origin_zip ), ( origin_state , destination_state , origin_zip ), ( origin_state , origin_zip ), ( origin_state , destination_state ), ( origin_state ), ( origin_state , destination_state ), ( origin_state ), ( origin_state , destination_state ), ( origin_state ), ( destination_state ), () ); However, if the query uses the DISTINCT quantifier for the GROUP BY : SELECT origin_state , destination_state , origin_zip , sum ( package_weight ) FROM shipping GROUP BY DISTINCT CUBE ( origin_state , destination_state ), ROLLUP ( origin_state , origin_zip ); only unique grouping sets are generated: SELECT origin_state , destination_state , origin_zip , sum ( package_weight ) FROM shipping GROUP BY GROUPING SETS ( ( origin_state , destination_state , origin_zip ), ( origin_state , origin_zip ), ( origin_state , destination_state ), ( origin_state ), ( destination_state ), () ); The default set quantifier is ALL . GROUPING operation # grouping(col1, ..., colN) -> bigint The grouping operation returns a bit set converted to decimal, indicating which columns are present in a grouping. It must be used in conjunction with GROUPING SETS , ROLLUP , CUBE or GROUP BY and its arguments must match exactly the columns referenced in the corresponding GROUPING SETS , ROLLUP , CUBE or GROUP BY clause. To compute the resulting bit set for a particular row, bits are assigned to the argument columns with the rightmost column being the least significant bit. For a given grouping, a bit is set to 0 if the corresponding column is included in the grouping and to 1 otherwise. For example, consider the query below: SELECT origin_state , origin_zip , destination_state , sum ( package_weight ), grouping ( origin_state , origin_zip , destination_state ) FROM shipping GROUP BY GROUPING SETS ( ( origin_state ), ( origin_state , origin_zip ), ( destination_state ) ); origin_state | origin_zip | destination_state | _col3 | _col4 --------------+------------+-------------------+-------+------- California | NULL | NULL | 1397 | 3 New Jersey | NULL | NULL | 225 | 3 New York | NULL | NULL | 3 | 3 California | 94131 | NULL | 60 | 1 New Jersey | 7081 | NULL | 225 | 1 California | 90210 | NULL | 1337 | 1 New York | 10002 | NULL | 3 | 1 NULL | NULL | New Jersey | 58 | 6 NULL | NULL | Connecticut | 1562 | 6 NULL | NULL | Colorado | 5 | 6 (10 rows) The first grouping in the above result only includes the origin_state column and excludes the origin_zip and destination_state columns. The bit set constructed for that grouping is 011 where the most significant bit represents origin_state . HAVING clause # The HAVING clause is used in conjunction with aggregate functions and the GROUP BY clause to control which groups are selected. A HAVING clause eliminates groups that do not satisfy the given conditions. HAVING filters groups after groups and aggregates are computed. The following example queries the customer table and selects groups with an account balance greater than the specified value: SELECT count ( * ), mktsegment , nationkey , CAST ( sum ( acctbal ) AS bigint ) AS totalbal FROM customer GROUP BY mktsegment , nationkey HAVING sum ( acctbal ) > 5700000 ORDER BY totalbal DESC ; _col0 | mktsegment | nationkey | totalbal -------+------------+-----------+---------- 1272 | AUTOMOBILE | 19 | 5856939 1253 | FURNITURE | 14 | 5794887 1248 | FURNITURE | 9 | 5784628 1243 | FURNITURE | 12 | 5757371 1231 | HOUSEHOLD | 3 | 5753216 1251 | MACHINERY | 2 | 5719140 1247 | FURNITURE | 8 | 5701952 (7 rows) WINDOW clause # The WINDOW clause is used to define named window specifications. The defined named window specifications can be referred to in the SELECT and ORDER BY clauses of the enclosing query: SELECT orderkey , clerk , totalprice , rank () OVER w AS rnk FROM orders WINDOW w AS ( PARTITION BY clerk ORDER BY totalprice DESC ) ORDER BY count () OVER w , clerk , rnk The window definition list of WINDOW clause can contain one or multiple named window specifications of the form window_name AS (window_specification) A window specification has the following components: The existing window name, which refers to a named window specification in the WINDOW clause. The window specification associated with the referenced name is the basis of the current specification. The partition specification, which separates the input rows into different partitions. This is analogous to how the GROUP BY clause separates rows into different groups for aggregate functions. The ordering specification, which determines the order in which input rows will be processed by the window function. The window frame, which specifies a sliding window of rows to be processed by the function for a given row. If the frame is not specified, it defaults to RANGE UNBOUNDED PRECEDING , which is the same as RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW . This frame contains all rows from the start of the partition up to the last peer of the current row. In the absence of ORDER BY , all rows are considered peers, so RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW is equivalent to BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING . The window frame syntax supports additional clauses for row pattern recognition. If the row pattern recognition clauses are specified, the window frame for a particular row consists of the rows matched by a pattern starting from that row. Additionally, if the frame specifies row pattern measures, they can be called over the window, similarly to window functions. For more details, see Row pattern recognition in window structures . Each window component is optional. If a window specification does not specify window partitioning, ordering or frame, those components are obtained from the window specification referenced by the existing window name , or from another window specification in the reference chain. In case when there is no existing window name specified, or none of the referenced window specifications contains the component, the default value is used. Set operations # UNION INTERSECT and EXCEPT are all set operations. These clauses are used to combine the results of more than one select statement into a single result set: query UNION [ALL | DISTINCT] query query INTERSECT [ALL | DISTINCT] query query EXCEPT [ALL | DISTINCT] query The argument ALL or DISTINCT controls which rows are included in the final result set. If the argument ALL is specified all rows are included even if the rows are identical. If the argument DISTINCT is specified only unique rows are included in the combined result set. If neither is specified, the behavior defaults to DISTINCT . Multiple set operations are processed left to right, unless the order is explicitly specified via parentheses. Additionally, INTERSECT binds more tightly than EXCEPT and UNION . That means A UNION B INTERSECT C EXCEPT D is the same as A UNION (B INTERSECT C) EXCEPT D . UNION clause # UNION combines all the rows that are in the result set from the first query with those that are in the result set for the second query. The following is an example of one of the simplest possible UNION clauses. It selects the value 13 and combines this result set with a second query that selects the value 42 : SELECT 13 UNION SELECT 42 ; _col0 ------- 13 42 (2 rows) The following query demonstrates the difference between UNION and UNION ALL . It selects the value 13 and combines this result set with a second query that selects the values 42 and 13 : SELECT 13 UNION SELECT * FROM ( VALUES 42 , 13 ); _col0 ------- 13 42 (2 rows) SELECT 13 UNION ALL SELECT * FROM ( VALUES 42 , 13 ); _col0 ------- 13 42 13 (2 rows) INTERSECT clause # INTERSECT returns only the rows that are in the result sets of both the first and the second queries. The following is an example of one of the simplest possible INTERSECT clauses. It selects the values 13 and 42 and combines this result set with a second query that selects the value 13 . Since 42 is only in the result set of the first query, it is not included in the final results.: SELECT * FROM ( VALUES 13 , 42 ) INTERSECT SELECT 13 ; _col0 ------- 13 (2 rows) EXCEPT clause # EXCEPT returns the rows that are in the result set of the first query, but not the second. The following is an example of one of the simplest possible EXCEPT clauses. It selects the values 13 and 42 and combines this result set with a second query that selects the value 13 . Since 13 is also in the result set of the second query, it is not included in the final result.: SELECT * FROM ( VALUES 13 , 42 ) EXCEPT SELECT 13 ; _col0 ------- 42 (2 rows) ORDER BY clause # The ORDER BY clause is used to sort a result set by one or more output expressions: ORDER BY expression [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] Each expression may be composed of output columns, or it may be an ordinal number selecting an output column by position, starting at one. The ORDER BY clause is evaluated after any GROUP BY or HAVING clause, and before any OFFSET , LIMIT or FETCH FIRST clause. The default null ordering is NULLS LAST , regardless of the ordering direction. Note that, following the SQL specification, an ORDER BY clause only affects the order of rows for queries that immediately contain the clause. Trino follows that specification, and drops redundant usage of the clause to avoid negative performance impacts. In the following example, the clause only applies to the select statement. INSERT INTO some_table SELECT * FROM another_table ORDER BY field ; Since tables in SQL are inherently unordered, and the ORDER BY clause in this case does not result in any difference, but negatively impacts performance of running the overall insert statement, Trino skips the sort operation. Another example where the ORDER BY clause is redundant, and does not affect the outcome of the overall statement, is a nested query: SELECT * FROM some_table JOIN ( SELECT * FROM another_table ORDER BY field ) u ON some_table . key = u . key ; More background information and details can be found in a blog post about this optimization . OFFSET clause # The OFFSET clause is used to discard a number of leading rows from the result set: OFFSET count [ ROW | ROWS ] If the ORDER BY clause is present, the OFFSET clause is evaluated over a sorted result set, and the set remains sorted after the leading rows are discarded: SELECT name FROM nation ORDER BY name OFFSET 22 ; name ---------------- UNITED KINGDOM UNITED STATES VIETNAM (3 rows) Otherwise, it is arbitrary which rows are discarded. If the count specified in the OFFSET clause equals or exceeds the size of the result set, the final result is empty. LIMIT or FETCH FIRST clause # The LIMIT or FETCH FIRST clause restricts the number of rows in the result set. LIMIT { count | ALL } FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } { ONLY | WITH TIES } The following example queries a large table, but the LIMIT clause restricts the output to only have five rows (because the query lacks an ORDER BY , exactly which rows are returned is arbitrary): SELECT orderdate FROM orders LIMIT 5 ; orderdate ------------ 1994-07-25 1993-11-12 1992-10-06 1994-01-04 1997-12-28 (5 rows) LIMIT ALL is the same as omitting the LIMIT clause. The FETCH FIRST clause supports either the FIRST or NEXT keywords and the ROW or ROWS keywords. These keywords are equivalent and the choice of keyword has no effect on query execution. If the count is not specified in the FETCH FIRST clause, it defaults to 1 : SELECT orderdate FROM orders FETCH FIRST ROW ONLY ; orderdate ------------ 1994-02-12 (1 row) If the OFFSET clause is present, the LIMIT or FETCH FIRST clause is evaluated after the OFFSET clause: SELECT * FROM ( VALUES 5 , 2 , 4 , 1 , 3 ) t ( x ) ORDER BY x OFFSET 2 LIMIT 2 ; x --- 3 4 (2 rows) For the FETCH FIRST clause, the argument ONLY or WITH TIES controls which rows are included in the result set. If the argument ONLY is specified, the result set is limited to the exact number of leading rows determined by the count. If the argument WITH TIES is specified, it is required that the ORDER BY clause be present. The result set consists of the same set of leading rows and all of the rows in the same peer group as the last of them (‘ties’) as established by the ordering in the ORDER BY clause. The result set is sorted: SELECT name , regionkey FROM nation ORDER BY regionkey FETCH FIRST ROW WITH TIES ; name | regionkey ------------+----------- ETHIOPIA | 0 MOROCCO | 0 KENYA | 0 ALGERIA | 0 MOZAMBIQUE | 0 (5 rows) TABLESAMPLE # There are multiple sample methods: BERNOULLI Each row is selected to be in the table sample with a probability of the sample percentage. When a table is sampled using the Bernoulli method, all physical blocks of the table are scanned and certain rows are skipped (based on a comparison between the sample percentage and a random value calculated at runtime). The probability of a row being included in the result is independent from any other row. This does not reduce the time required to read the sampled table from disk. It may have an impact on the total query time if the sampled output is processed further. SYSTEM This sampling method divides the table into logical segments of data and samples the table at this granularity. This sampling method either selects all the rows from a particular segment of data or skips it (based on a comparison between the sample percentage and a random value calculated at runtime). The rows selected in a system sampling will be dependent on which connector is used. For example, when used with Hive, it is dependent on how the data is laid out on HDFS. This method does not guarantee independent sampling probabilities. Note Neither of the two methods allow deterministic bounds on the number of rows returned. Examples: SELECT * FROM users TABLESAMPLE BERNOULLI ( 50 ); SELECT * FROM users TABLESAMPLE SYSTEM ( 75 ); Using sampling with joins: SELECT o . * , i . * FROM orders o TABLESAMPLE SYSTEM ( 10 ) JOIN lineitem i TABLESAMPLE BERNOULLI ( 40 ) ON o . orderkey = i . orderkey ; UNNEST # UNNEST can be used to expand an ARRAY or MAP into a relation. Arrays are expanded into a single column: SELECT * FROM UNNEST ( ARRAY [ 1 , 2 ]) AS t ( number ); number -------- 1 2 (2 rows) Maps are expanded into two columns (key, value): SELECT * FROM UNNEST ( map_from_entries ( ARRAY [ ( 'SQL' , 1974 ), ( 'Java' , 1995 ) ] ) ) AS t ( language , first_appeared_year ); language | first_appeared_year ----------+--------------------- SQL | 1974 Java | 1995 (2 rows) UNNEST can be used in combination with an ARRAY of ROW structures for expanding each field of the ROW into a corresponding column: SELECT * FROM UNNEST ( ARRAY [ ROW ( 'Java' , 1995 ), ROW ( 'SQL' , 1974 )], ARRAY [ ROW ( false ), ROW ( true )] ) as t ( language , first_appeared_year , declarative ); language | first_appeared_year | declarative ----------+---------------------+------------- Java | 1995 | false SQL | 1974 | true (2 rows) UNNEST can optionally have a WITH ORDINALITY clause, in which case an additional ordinality column is added to the end: SELECT a , b , rownumber FROM UNNEST ( ARRAY [ 2 , 5 ], ARRAY [ 7 , 8 , 9 ] ) WITH ORDINALITY AS t ( a , b , rownumber ); a | b | rownumber ------+---+----------- 2 | 7 | 1 5 | 8 | 2 NULL | 9 | 3 (3 rows) UNNEST returns zero entries when the array/map is empty: SELECT * FROM UNNEST ( ARRAY []) AS t ( value ); value ------- (0 rows) UNNEST returns zero entries when the array/map is null: SELECT * FROM UNNEST ( CAST ( null AS ARRAY ( integer ))) AS t ( number ); number -------- (0 rows) UNNEST is normally used with a JOIN , and can reference columns from relations on the left side of the join: SELECT student , score FROM ( VALUES ( 'John' , ARRAY [ 7 , 10 , 9 ]), ( 'Mary' , ARRAY [ 4 , 8 , 9 ]) ) AS tests ( student , scores ) CROSS JOIN UNNEST ( scores ) AS t ( score ); student | score ---------+------- John | 7 John | 10 John | 9 Mary | 4 Mary | 8 Mary | 9 (6 rows) UNNEST can also be used with multiple arguments, in which case they are expanded into multiple columns, with as many rows as the highest cardinality argument (the other columns are padded with nulls): SELECT numbers , animals , n , a FROM ( VALUES ( ARRAY [ 2 , 5 ], ARRAY [ 'dog' , 'cat' , 'bird' ]), ( ARRAY [ 7 , 8 , 9 ], ARRAY [ 'cow' , 'pig' ]) ) AS x ( numbers , animals ) CROSS JOIN UNNEST ( numbers , animals ) AS t ( n , a ); numbers | animals | n | a -----------+------------------+------+------ [2, 5] | [dog, cat, bird] | 2 | dog [2, 5] | [dog, cat, bird] | 5 | cat [2, 5] | [dog, cat, bird] | NULL | bird [7, 8, 9] | [cow, pig] | 7 | cow [7, 8, 9] | [cow, pig] | 8 | pig [7, 8, 9] | [cow, pig] | 9 | NULL (6 rows) LEFT JOIN is preferable in order to avoid losing the row containing the array/map field in question when referenced columns from relations on the left side of the join can be empty or have NULL values: SELECT runner , checkpoint FROM ( VALUES ( 'Joe' , ARRAY [ 10 , 20 , 30 , 42 ]), ( 'Roger' , ARRAY [ 10 ]), ( 'Dave' , ARRAY []), ( 'Levi' , NULL ) ) AS marathon ( runner , checkpoints ) LEFT JOIN UNNEST ( checkpoints ) AS t ( checkpoint ) ON TRUE ; runner | checkpoint --------+------------ Joe | 10 Joe | 20 Joe | 30 Joe | 42 Roger | 10 Dave | NULL Levi | NULL (7 rows) Note that in case of using LEFT JOIN the only condition supported by the current implementation is ON TRUE . JSON_TABLE # JSON_TABLE transforms JSON data into a relational table format. Like UNNEST and LATERAL , use JSON_TABLE in the FROM clause of a SELECT statement. For more information, see JSON_TABLE . Joins # Joins allow you to combine data from multiple relations. CROSS JOIN # A cross join returns the Cartesian product (all combinations) of two relations. Cross joins can either be specified using the explit CROSS JOIN syntax or by specifying multiple relations in the FROM clause. Both of the following queries are equivalent: SELECT * FROM nation CROSS JOIN region ; SELECT * FROM nation , region ; The nation table contains 25 rows and the region table contains 5 rows, so a cross join between the two tables produces 125 rows: SELECT n . name AS nation , r . name AS region FROM nation AS n CROSS JOIN region AS r ORDER BY 1 , 2 ; nation | region ----------------+------------- ALGERIA | AFRICA ALGERIA | AMERICA ALGERIA | ASIA ALGERIA | EUROPE ALGERIA | MIDDLE EAST ARGENTINA | AFRICA ARGENTINA | AMERICA ... (125 rows) LATERAL # Subqueries appearing in the FROM clause can be preceded by the keyword LATERAL . This allows them to reference columns provided by preceding FROM items. A LATERAL join can appear at the top level in the FROM list, or anywhere within a parenthesized join tree. In the latter case, it can also refer to any items that are on the left-hand side of a JOIN for which it is on the right-hand side. When a FROM item contains LATERAL cross-references, evaluation proceeds as follows: for each row of the FROM item providing the cross-referenced columns, the LATERAL item is evaluated using that row set’s values of the columns. The resulting rows are joined as usual with the rows they were computed from. This is repeated for set of rows from the column source tables. LATERAL is primarily useful when the cross-referenced column is necessary for computing the rows to be joined: SELECT name , x , y FROM nation CROSS JOIN LATERAL ( SELECT name || ' :-' AS x ) CROSS JOIN LATERAL ( SELECT x || ')' AS y ); Qualifying column names # When two relations in a join have columns with the same name, the column references must be qualified using the relation alias (if the relation has an alias), or with the relation name: SELECT nation . name , region . name FROM nation CROSS JOIN region ; SELECT n . name , r . name FROM nation AS n CROSS JOIN region AS r ; SELECT n . name , r . name FROM nation n CROSS JOIN region r ; The following query will fail with the error Column 'name' is ambiguous : SELECT name FROM nation CROSS JOIN region ; Subqueries # A subquery is an expression which is composed of a query. The subquery is correlated when it refers to columns outside of the subquery. Logically, the subquery will be evaluated for each row in the surrounding query. The referenced columns will thus be constant during any single evaluation of the subquery. Note Support for correlated subqueries is limited. Not every standard form is supported. EXISTS # The EXISTS predicate determines if a subquery returns any rows: SELECT name FROM nation WHERE EXISTS ( SELECT * FROM region WHERE region . regionkey = nation . regionkey ); IN # The IN predicate determines if any values produced by the subquery are equal to the provided expression. The result of IN follows the standard rules for nulls. The subquery must produce exactly one column: SELECT name FROM nation WHERE regionkey IN ( SELECT regionkey FROM region WHERE name = 'AMERICA' OR name = 'AFRICA' ); Scalar subquery # A scalar subquery is a non-correlated subquery that returns zero or one row. It is an error for the subquery to produce more than one row. The returned value is NULL if the subquery produces no rows: SELECT name FROM nation WHERE regionkey = ( SELECT max ( regionkey ) FROM region ); Note Currently only single column can be returned from the scalar subquery. Previous ROLLBACK Next SET PATH

SET PATH — Trino 474 Documentation Skip to content Trino 474 Documentation SET PATH  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET PATH Contents Synopsis Description Examples See also SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also SET PATH # Synopsis # SET PATH path-element[, ...] Description # Define a collection of paths to functions or table functions in specific catalogs and schemas for the current session. Each path-element uses a period-separated syntax to specify the catalog name and schema location <catalog>.<schema> of the function, or only the schema location <schema> in the current catalog. The current catalog is set with USE , or as part of a client tool connection. Catalog and schema must exist. Examples # The following example sets a path to access functions in the system schema of the example catalog: SET PATH example . system ; The catalog uses the PostgreSQL connector, and you can therefore use the query table function directly, without the full catalog and schema qualifiers: SELECT * FROM TABLE ( query ( query => 'SELECT * FROM tpch.nation' ) ); See also # USE SQL environment properties Previous SELECT Next SET ROLE

SET ROLE — Trino 474 Documentation Skip to content Trino 474 Documentation SET ROLE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET ROLE Contents Synopsis Description Limitations See also SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Limitations See also SET ROLE # Synopsis # SET ROLE ( role | ALL | NONE ) [ IN catalog ] Description # SET ROLE sets the enabled role for the current session. SET ROLE role enables a single specified role for the current session. For the SET ROLE role statement to succeed, the user executing it should have a grant for the given role. SET ROLE ALL enables all roles that the current user has been granted for the current session. SET ROLE NONE disables all the roles granted to the current user for the current session. The optional IN catalog clause sets the role in a catalog as opposed to a system role. Limitations # Some connectors do not support role management. See connector documentation for more details. See also # CREATE ROLE , DROP ROLE , GRANT role , REVOKE role Previous SET PATH Next SET SESSION

SET SESSION — Trino 474 Documentation Skip to content Trino 474 Documentation SET SESSION  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION Contents Synopsis Description Session properties Examples See also SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Session properties Examples See also SET SESSION # Synopsis # SET SESSION name = expression SET SESSION catalog.name = expression Description # Set a session property value or a catalog session property. Session properties # A session property is a configuration property that can be temporarily modified by a user for the duration of the current connection session to the Trino cluster. Many configuration properties have a corresponding session property that accepts the same values as the config property. There are two types of session properties: System session properties apply to the whole cluster. Most session properties are system session properties unless specified otherwise. Catalog session properties are connector-defined session properties that can be set on a per-catalog basis. These properties must be set separately for each catalog by including the catalog name as a prefix, such as catalogname.property_name . Session properties are tied to the current session, so a user can have multiple connections to a cluster that each have different values for the same session properties. Once a session ends, either by disconnecting or creating a new session, any changes made to session properties during the previous session are lost. Examples # The following example sets a system session property change maximum query run time: SET SESSION query_max_run_time = '10m' ; The following example sets the incremental_refresh_enabled catalog session property for a catalog using the Iceberg connector named example : SET SESSION example . incremental_refresh_enabled = false ; The related catalog configuration property iceberg.incremental-refresh-enabled defaults to true , and the session property allows you to override this setting in for specific catalog and the current session. The example.incremental_refresh_enabled catalog session property does not apply to any other catalog, even if another catalog also uses the Iceberg connector. See also # RESET SESSION , SHOW SESSION Previous SET ROLE Next SET SESSION AUTHORIZATION

SET SESSION AUTHORIZATION — Trino 474 Documentation Skip to content Trino 474 Documentation SET SESSION AUTHORIZATION  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET SESSION AUTHORIZATION Contents Synopsis Description Examples See also SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also SET SESSION AUTHORIZATION # Synopsis # SET SESSION AUTHORIZATION username Description # Changes the current user of the session. For the SET SESSION AUTHORIZATION username statement to succeed, the original user (that the client connected with) must be able to impersonate the specified user. User impersonation can be enabled in the system access control. Examples # In the following example, the original user when the connection to Trino is made is Kevin. The following sets the session authorization user to John: SET SESSION AUTHORIZATION 'John' ; Queries will now execute as John instead of Kevin. All supported syntax to change the session authorization users are shown below. Changing the session authorization with single quotes: SET SESSION AUTHORIZATION 'John' ; Changing the session authorization with double quotes: SET SESSION AUTHORIZATION "John" ; Changing the session authorization without quotes: SET SESSION AUTHORIZATION John ; See also # RESET SESSION AUTHORIZATION Previous SET SESSION Next SET TIME ZONE

SET TIME ZONE — Trino 474 Documentation Skip to content Trino 474 Documentation SET TIME ZONE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SET TIME ZONE Contents Synopsis Description Examples Limitations See also SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples Limitations See also SET TIME ZONE # Synopsis # SET TIME ZONE LOCAL SET TIME ZONE expression Description # Sets the default time zone for the current session. If the LOCAL option is specified, the time zone for the current session is set to the initial time zone of the session. If the expression option is specified: if the type of the expression is a string, the time zone for the current session is set to the corresponding region-based time zone ID or the corresponding zone offset. if the type of the expression is an interval, the time zone for the current session is set to the corresponding zone offset relative to UTC. It must be in the range of [-14,14] hours. Examples # Use the default time zone for the current session: SET TIME ZONE LOCAL ; Use a zone offset for specifying the time zone: SET TIME ZONE '-08:00' ; Use an interval literal for specifying the time zone: SET TIME ZONE INTERVAL '10' HOUR ; SET TIME ZONE INTERVAL - '08:00' HOUR TO MINUTE ; Use a region-based time zone identifier for specifying the time zone: SET TIME ZONE 'America/Los_Angeles' ; The time zone identifier to be used can be passed as the output of a function call: SET TIME ZONE concat_ws ( '/' , 'America' , 'Los_Angeles' ); Limitations # Setting the default time zone for the session has no effect if the sql.forced-session-time-zone configuration property is already set. See also # current_timezone() Previous SET SESSION AUTHORIZATION Next SHOW CATALOGS

SHOW CATALOGS — Trino 474 Documentation Skip to content Trino 474 Documentation SHOW CATALOGS  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW CATALOGS Contents Synopsis Description SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description SHOW CATALOGS # Synopsis # SHOW CATALOGS [ LIKE pattern ] Description # List the available catalogs. Specify a pattern in the optional LIKE clause to filter the results to the desired subset. For example, the following query allows you to find catalogs that begin with t : SHOW CATALOGS LIKE 't%' Previous SET TIME ZONE Next SHOW COLUMNS

SHOW COLUMNS — Trino 474 Documentation Skip to content Trino 474 Documentation SHOW COLUMNS  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW COLUMNS Contents Synopsis Description SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description SHOW COLUMNS # Synopsis # SHOW COLUMNS FROM table [ LIKE pattern ] Description # List the columns in a table along with their data type and other attributes: SHOW COLUMNS FROM nation ; Column | Type | Extra | Comment -----------+--------------+-------+--------- nationkey | bigint | | name | varchar(25) | | regionkey | bigint | | comment | varchar(152) | | Specify a pattern in the optional LIKE clause to filter the results to the desired subset. For example, the following query allows you to find columns ending in key : SHOW COLUMNS FROM nation LIKE '%key' ; Column | Type | Extra | Comment -----------+--------------+-------+--------- nationkey | bigint | | regionkey | bigint | | Previous SHOW CATALOGS Next SHOW CREATE FUNCTION

SHOW CREATE FUNCTION — Trino 474 Documentation Skip to content Trino 474 Documentation SHOW CREATE FUNCTION  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE FUNCTION Contents Synopsis Description Examples See also SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also SHOW CREATE FUNCTION # Synopsis # SHOW CREATE FUNCTION function_name Description # Show the SQL statement that creates the specified function. Examples # Show the SQL that can be run to create the meaning_of_life function: SHOW CREATE FUNCTION example . default . meaning_of_life ; See also # CREATE FUNCTION DROP FUNCTION SHOW FUNCTIONS User-defined functions SQL environment properties Previous SHOW COLUMNS Next SHOW CREATE MATERIALIZED VIEW

SHOW CREATE MATERIALIZED VIEW — Trino 474 Documentation Skip to content Trino 474 Documentation SHOW CREATE MATERIALIZED VIEW  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE MATERIALIZED VIEW Contents Synopsis Description See also SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description See also SHOW CREATE MATERIALIZED VIEW # Synopsis # SHOW CREATE MATERIALIZED VIEW view_name Description # Show the SQL statement that creates the specified materialized view view_name . See also # CREATE MATERIALIZED VIEW DROP MATERIALIZED VIEW REFRESH MATERIALIZED VIEW Previous SHOW CREATE FUNCTION Next SHOW CREATE SCHEMA

SHOW CREATE SCHEMA — Trino 474 Documentation Skip to content Trino 474 Documentation SHOW CREATE SCHEMA  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE SCHEMA Contents Synopsis Description See also SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description See also SHOW CREATE SCHEMA # Synopsis # SHOW CREATE SCHEMA schema_name Description # Show the SQL statement that creates the specified schema. See also # CREATE SCHEMA Previous SHOW CREATE MATERIALIZED VIEW Next SHOW CREATE TABLE

SHOW CREATE TABLE — Trino 474 Documentation Skip to content Trino 474 Documentation SHOW CREATE TABLE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE TABLE Contents Synopsis Description Examples See also SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also SHOW CREATE TABLE # Synopsis # SHOW CREATE TABLE table_name Description # Show the SQL statement that creates the specified table. Examples # Show the SQL that can be run to create the orders table: SHOW CREATE TABLE sf1 . orders ; Create Table ----------------------------------------- CREATE TABLE tpch.sf1.orders ( orderkey bigint, orderstatus varchar, totalprice double, orderdate varchar ) WITH ( format = 'ORC', partitioned_by = ARRAY['orderdate'] ) (1 row) See also # CREATE TABLE Previous SHOW CREATE SCHEMA Next SHOW CREATE VIEW

SHOW CREATE VIEW — Trino 474 Documentation Skip to content Trino 474 Documentation SHOW CREATE VIEW  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW CREATE VIEW Contents Synopsis Description See also SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description See also SHOW CREATE VIEW # Synopsis # SHOW CREATE VIEW view_name Description # Show the SQL statement that creates the specified view. See also # CREATE VIEW Previous SHOW CREATE TABLE Next SHOW FUNCTIONS

SHOW FUNCTIONS — Trino 474 Documentation Skip to content Trino 474 Documentation SHOW FUNCTIONS  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW FUNCTIONS Contents Synopsis Description Examples See also SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also SHOW FUNCTIONS # Synopsis # SHOW FUNCTIONS [ FROM schema ] [ LIKE pattern ] Description # List functions in schema or all functions in the current session path. This can include built-in functions, functions from a custom plugin , and User-defined functions . For each function returned, the following information is displayed: Function name Return type Argument types Function type Deterministic Description Use the optional FROM keyword to only list functions in a specific catalog and schema. The location in schema must be specified as cataglog_name.schema_name . Specify a pattern in the optional LIKE clause to filter the results to the desired subset. Examples # List all UDFs and plugin functions in the default schema of the example catalog: SHOW FUNCTIONS FROM example . default ; List all functions with a name beginning with array : SHOW FUNCTIONS LIKE 'array%' ; List all functions with a name beginning with cf : SHOW FUNCTIONS LIKE 'cf%' ; Example output: Function | Return Type | Argument Types | Function Type | Deterministic | Description ------------------+-------------+----------------+---------------+---------------+----------------------------------------- cf_getgroups | varchar | | scalar | true | Returns the current session's groups cf_getprincipal | varchar | | scalar | true | Returns the current session's principal cf_getuser | varchar | | scalar | true | Returns the current session's user See also # Functions and operators User-defined functions Functions CREATE FUNCTION DROP FUNCTION SHOW CREATE FUNCTION Previous SHOW CREATE VIEW Next SHOW GRANTS

SHOW GRANTS — Trino 474 Documentation Skip to content Trino 474 Documentation SHOW GRANTS  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW GRANTS Contents Synopsis Description Examples Limitations See also SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples Limitations See also SHOW GRANTS # Synopsis # SHOW GRANTS [ ON [ TABLE ] table_name ] Description # List the grants for the current user on the specified table in the current catalog. If no table name is specified, the command lists the grants for the current user on all the tables in all schemas of the current catalog. The command requires the current catalog to be set. Note Ensure that authentication has been enabled before running any of the authorization commands. Examples # List the grants for the current user on table orders : SHOW GRANTS ON TABLE orders ; List the grants for the current user on all the tables in all schemas of the current catalog: SHOW GRANTS ; Limitations # Some connectors have no support for SHOW GRANTS . See connector documentation for more details. See also # GRANT privilege , REVOKE privilege Previous SHOW FUNCTIONS Next SHOW ROLE GRANTS

SHOW ROLE GRANTS — Trino 474 Documentation Skip to content Trino 474 Documentation SHOW ROLE GRANTS  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLE GRANTS Contents Synopsis Description SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description SHOW ROLE GRANTS # Synopsis # SHOW ROLE GRANTS [ FROM catalog ] Description # List non-recursively the system roles or roles in catalog that have been granted to the session user. Previous SHOW GRANTS Next SHOW ROLES

SHOW ROLES — Trino 474 Documentation Skip to content Trino 474 Documentation SHOW ROLES  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW ROLES Contents Synopsis Description SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description SHOW ROLES # Synopsis # SHOW [CURRENT] ROLES [ FROM catalog ] Description # SHOW ROLES lists all the system roles or all the roles in catalog . SHOW CURRENT ROLES lists the enabled system roles or roles in catalog . Previous SHOW ROLE GRANTS Next SHOW SCHEMAS

SHOW SCHEMAS — Trino 474 Documentation Skip to content Trino 474 Documentation SHOW SCHEMAS  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SCHEMAS Contents Synopsis Description SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description SHOW SCHEMAS # Synopsis # SHOW SCHEMAS [ FROM catalog ] [ LIKE pattern ] Description # List the schemas in catalog or in the current catalog. Specify a pattern in the optional LIKE clause to filter the results to the desired subset. For example, the following query allows you to find schemas that have 3 as the third character: SHOW SCHEMAS FROM tpch LIKE '__3%' Previous SHOW ROLES Next SHOW SESSION

SHOW SESSION — Trino 474 Documentation Skip to content Trino 474 Documentation SHOW SESSION  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW SESSION Contents Synopsis Description See also SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description See also SHOW SESSION # Synopsis # SHOW SESSION [ LIKE pattern ] Description # List the current session properties . Specify a pattern in the optional LIKE clause to filter the results to the desired subset. For example, the following query allows you to find session properties that begin with query : SHOW SESSION LIKE 'query%' See also # RESET SESSION , SET SESSION Previous SHOW SCHEMAS Next SHOW STATS

SHOW STATS — Trino 474 Documentation Skip to content Trino 474 Documentation SHOW STATS  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW STATS Contents Synopsis Description SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description SHOW STATS # Synopsis # SHOW STATS FOR table SHOW STATS FOR ( query ) Description # Returns approximated statistics for the named table or for the results of a query. Returns NULL for any statistics that are not populated or unavailable on the data source. Statistics are returned as a row for each column, plus a summary row for the table (identifiable by a NULL value for column_name ). The following table lists the returned columns and what statistics they represent. Any additional statistics collected on the data source, other than those listed here, are not included. Statistics # Column Description Notes column_name The name of the column NULL in the table summary row data_size The total size in bytes of all of the values in the column NULL in the table summary row. Available for columns of string data types with variable widths. distinct_values_count The estimated number of distinct values in the column NULL in the table summary row nulls_fractions The portion of the values in the column that are NULL NULL in the table summary row. row_count The estimated number of rows in the table NULL in column statistic rows low_value The lowest value found in this column NULL in the table summary row. Available for columns of DATE , integer , floating-point , and exact numeric data types. high_value The highest value found in this column NULL in the table summary row. Available for columns of DATE , integer , floating-point , and exact numeric data types. Previous SHOW SESSION Next SHOW TABLES

SHOW TABLES — Trino 474 Documentation Skip to content Trino 474 Documentation SHOW TABLES  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES SHOW TABLES Contents Synopsis Description Examples See also START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also SHOW TABLES # Synopsis # SHOW TABLES [ FROM schema ] [ LIKE pattern ] Description # List the tables and views in the current schema, for example set with USE or by a client connection. Use a fully qualified path to a schema in the form of catalog_name.schema_name to specify any schema in any catalog in the FROM clause. Specify a pattern in the optional LIKE clause to filter the results to the desired subset. Examples # The following query lists tables and views that begin with p in the tiny schema of the tpch catalog: SHOW TABLES FROM tpch . tiny LIKE 'p%' ; See also # Schema and table management View management Previous SHOW STATS Next START TRANSACTION

START TRANSACTION — Trino 474 Documentation Skip to content Trino 474 Documentation START TRANSACTION  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION START TRANSACTION Contents Synopsis Description Examples See also TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also START TRANSACTION # Synopsis # START TRANSACTION [ mode [, ...] ] where mode is one of ISOLATION LEVEL { READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE } READ { ONLY | WRITE } Description # Start a new transaction for the current session. Examples # START TRANSACTION ; START TRANSACTION ISOLATION LEVEL REPEATABLE READ ; START TRANSACTION READ WRITE ; START TRANSACTION ISOLATION LEVEL READ COMMITTED , READ ONLY ; START TRANSACTION READ WRITE , ISOLATION LEVEL SERIALIZABLE ; See also # COMMIT , ROLLBACK Previous SHOW TABLES Next TRUNCATE

TRUNCATE — Trino 474 Documentation Skip to content Trino 474 Documentation TRUNCATE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE TRUNCATE Contents Synopsis Description Examples UPDATE USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples TRUNCATE # Synopsis # TRUNCATE TABLE table_name Description # Delete all rows from a table. Examples # Truncate the table orders : TRUNCATE TABLE orders ; Previous START TRANSACTION Next UPDATE

UPDATE — Trino 474 Documentation Skip to content Trino 474 Documentation UPDATE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE UPDATE Contents Synopsis Description Examples Limitations USE VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples Limitations UPDATE # Synopsis # UPDATE table_name SET [ ( column = expression [, ... ] ) ] [ WHERE condition ] Description # Update selected columns values in existing rows in a table. The columns named in the column = expression assignments will be updated for all rows that match the WHERE condition. The values of all column update expressions for a matching row are evaluated before any column value is changed. When the type of the expression and the type of the column differ, the usual implicit CASTs, such as widening numeric fields, are applied to the UPDATE expression values. Examples # Update the status of all purchases that haven’t been assigned a ship date: UPDATE purchases SET status = 'OVERDUE' WHERE ship_date IS NULL ; Update the account manager and account assign date for all customers: UPDATE customers SET account_manager = 'John Henry' , assign_date = now (); Update the manager to be the name of the employee who matches the manager ID: UPDATE new_hires SET manager = ( SELECT e . name FROM employees e WHERE e . employee_id = new_hires . manager_id ); Limitations # Some connectors have limited or no support for UPDATE . See connector documentation for more details. Previous TRUNCATE Next USE

USE — Trino 474 Documentation Skip to content Trino 474 Documentation USE  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE USE Contents Synopsis Description Examples VALUES Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples USE # Synopsis # USE catalog.schema USE schema Description # Update the session to use the specified catalog and schema. If a catalog is not specified, the schema is resolved relative to the current catalog. Examples # USE hive . finance ; USE information_schema ; Previous UPDATE Next VALUES

VALUES — Trino 474 Documentation Skip to content Trino 474 Documentation VALUES  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES VALUES Contents Synopsis Description Examples See also Row pattern recognition in window structures Developer guide Glossary Appendix Release notes Contents Synopsis Description Examples See also VALUES # Synopsis # VALUES row [, ...] where row is a single expression or ( column_expression [, ...] ) Description # Defines a literal inline table. VALUES can be used anywhere a query can be used (e.g., the FROM clause of a SELECT , an INSERT , or even at the top level). VALUES creates an anonymous table without column names, but the table and columns can be named using an AS clause with column aliases. Examples # Return a table with one column and three rows: VALUES 1 , 2 , 3 Return a table with two columns and three rows: VALUES ( 1 , 'a' ), ( 2 , 'b' ), ( 3 , 'c' ) Return table with column id and name : SELECT * FROM ( VALUES ( 1 , 'a' ), ( 2 , 'b' ), ( 3 , 'c' ) ) AS t ( id , name ) Create a new table with column id and name : CREATE TABLE example AS SELECT * FROM ( VALUES ( 1 , 'a' ), ( 2 , 'b' ), ( 3 , 'c' ) ) AS t ( id , name ) See also # INSERT , SELECT Previous USE Next Row pattern recognition in window structures

Row pattern recognition in window structures — Trino 474 Documentation Skip to content Trino 474 Documentation Row pattern recognition in window structures  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax ALTER MATERIALIZED VIEW ALTER SCHEMA ALTER TABLE ALTER VIEW ANALYZE CALL COMMENT COMMIT CREATE CATALOG CREATE FUNCTION CREATE MATERIALIZED VIEW CREATE ROLE CREATE SCHEMA CREATE TABLE CREATE TABLE AS CREATE VIEW DEALLOCATE PREPARE DELETE DENY DESCRIBE DESCRIBE INPUT DESCRIBE OUTPUT DROP CATALOG DROP FUNCTION DROP MATERIALIZED VIEW DROP ROLE DROP SCHEMA DROP TABLE DROP VIEW EXECUTE EXECUTE IMMEDIATE EXPLAIN EXPLAIN ANALYZE GRANT privilege GRANT role INSERT MATCH_RECOGNIZE MERGE PREPARE REFRESH MATERIALIZED VIEW RESET SESSION RESET SESSION AUTHORIZATION REVOKE privilege REVOKE role ROLLBACK SELECT SET PATH SET ROLE SET SESSION SET SESSION AUTHORIZATION SET TIME ZONE SHOW CATALOGS SHOW COLUMNS SHOW CREATE FUNCTION SHOW CREATE MATERIALIZED VIEW SHOW CREATE SCHEMA SHOW CREATE TABLE SHOW CREATE VIEW SHOW FUNCTIONS SHOW GRANTS SHOW ROLE GRANTS SHOW ROLES SHOW SCHEMAS SHOW SESSION SHOW STATS SHOW TABLES START TRANSACTION TRUNCATE UPDATE USE VALUES Row pattern recognition in window structures Row pattern recognition in window structures Contents Window with row pattern recognition Description of the pattern recognition clauses Processing input with row pattern recognition Empty matches and unmatched rows Developer guide Glossary Appendix Release notes Contents Window with row pattern recognition Description of the pattern recognition clauses Processing input with row pattern recognition Empty matches and unmatched rows Row pattern recognition in window structures # A window structure can be defined in the WINDOW clause or in the OVER clause of a window operation. In both cases, the window specification can include row pattern recognition clauses. They are part of the window frame. The syntax and semantics of row pattern recognition in window are similar to those of the MATCH_RECOGNIZE clause. This section explains the details of row pattern recognition in window structures, and highlights the similarities and the differences between both pattern recognition mechanisms. Window with row pattern recognition # Window specification: ( [ existing_window_name ] [ PARTITION BY column [, ...] ] [ ORDER BY column [, ...] ] [ window_frame ] ) Window frame: [ MEASURES measure_definition [, ...] ] frame_extent [ AFTER MATCH skip_to ] [ INITIAL | SEEK ] [ PATTERN ( row_pattern ) ] [ SUBSET subset_definition [, ...] ] [ DEFINE variable_definition [, ...] ] Generally, a window frame specifies the frame_extent , which defines the “sliding window” of rows to be processed by a window function. It can be defined in terms of ROWS , RANGE or GROUPS . A window frame with row pattern recognition involves many other syntactical components, mandatory or optional, and enforces certain limitations on the frame_extent . Window frame with row pattern recognition: [ MEASURES measure_definition [, ...] ] ROWS BETWEEN CURRENT ROW AND frame_end [ AFTER MATCH skip_to ] [ INITIAL | SEEK ] PATTERN ( row_pattern ) [ SUBSET subset_definition [, ...] ] DEFINE variable_definition [, ...] Description of the pattern recognition clauses # The frame_extent with row pattern recognition must be defined in terms of ROWS . The frame start must be at the CURRENT ROW , which limits the allowed frame extent values to the following: ROWS BETWEEN CURRENT ROW AND CURRENT ROW ROWS BETWEEN CURRENT ROW AND < expression > FOLLOWING ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING For every input row processed by the window, the portion of rows enclosed by the frame_extent limits the search area for row pattern recognition. Unlike in MATCH_RECOGNIZE , where the pattern search can explore all rows until the partition end, and all rows of the partition are available for computations, in window structures the pattern matching can neither match rows nor retrieve input values outside the frame. Besides the frame_extent , pattern matching requires the PATTERN and DEFINE clauses. The PATTERN clause specifies a row pattern, which is a form of a regular expression with some syntactical extensions. The row pattern syntax is similar to the row pattern syntax in MATCH_RECOGNIZE . However, the anchor patterns ^ and $ are not allowed in a window specification. The DEFINE clause defines the row pattern primary variables in terms of boolean conditions that must be satisfied. It is similar to the DEFINE clause of MATCH_RECOGNIZE . The only difference is that the window syntax does not support the MATCH_NUMBER function. The MEASURES clause is syntactically similar to the MEASURES clause of MATCH_RECOGNIZE . The only limitation is that the MATCH_NUMBER function is not allowed. However, the semantics of this clause differs between MATCH_RECOGNIZE and window. While in MATCH_RECOGNIZE every measure produces an output column, the measures in window should be considered as definitions associated with the window structure. They can be called over the window, in the same manner as regular window functions: SELECT cust_key , value OVER w , label OVER w FROM orders WINDOW w AS ( PARTITION BY cust_key ORDER BY order_date MEASURES RUNNING LAST ( total_price ) AS value , CLASSIFIER () AS label ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING PATTERN ( A B + C + ) DEFINE B AS B . value < PREV ( B . value ), C AS C . value > PREV ( C . value ) ) Measures defined in a window can be referenced in the SELECT clause and in the ORDER BY clause of the enclosing query. The RUNNING and FINAL keywords are allowed in the MEASURES clause. They can precede a logical navigation function FIRST or LAST , or an aggregate function. However, they have no effect. Every computation is performed from the position of the final row of the match, so the semantics is effectively FINAL . The AFTER MATCH SKIP clause has the same syntax as the AFTER MATCH SKIP clause of MATCH_RECOGNIZE . The INITIAL or SEEK modifier is specific to row pattern recognition in window. With INITIAL , which is the default, the pattern match for an input row can only be found starting from that row. With SEEK , if there is no match starting from the current row, the engine tries to find a match starting from subsequent rows within the frame. As a result, it is possible to associate an input row with a match which is detached from that row. The SUBSET clause is used to define union variables as sets of primary pattern variables. You can use union variables to refer to a set of rows matched to any primary pattern variable from the subset: SUBSET U = ( A , B ) The following expression returns the total_price value from the last row matched to either A or B : LAST ( U . total_price ) If you want to refer to all rows of the match, there is no need to define a SUBSET containing all pattern variables. There is an implicit universal pattern variable applied to any non prefixed column name and any CLASSIFIER call without an argument. The following expression returns the total_price value from the last matched row: LAST ( total_price ) The following call returns the primary pattern variable of the first matched row: FIRST ( CLASSIFIER ()) In window, unlike in MATCH_RECOGNIZE , you cannot specify ONE ROW PER MATCH or ALL ROWS PER MATCH . This is because all calls over window, whether they are regular window functions or measures, must comply with the window semantics. A call over window is supposed to produce exactly one output row for every input row. And so, the output mode of pattern recognition in window is a combination of ONE ROW PER MATCH and WITH UNMATCHED ROWS . Processing input with row pattern recognition # Pattern recognition in window processes input rows in two different cases: upon a row pattern measure call over the window: some_measure OVER w upon a window function call over the window: sum ( total_price ) OVER w The output row produced for each input row, consists of: all values from the input row the value of the called measure or window function, computed with respect to the pattern match associated with the row Processing the input can be described as the following sequence of steps: Partition the input data accordingly to PARTITION BY Order each partition by the ORDER BY expressions For every row of the ordered partition: If the row is ‘skipped’ by a match of some previous row: For a measure, produce a one-row output as for an unmatched row For a window function, evaluate the function over an empty frame and produce a one-row output Otherwise: Determine the frame extent Try match the row pattern starting from the current row within the frame extent If no match is found, and SEEK is specified, try to find a match starting from subsequent rows within the frame extent If no match is found: For a measure, produce a one-row output for an unmatched row For a window function, evaluate the function over an empty frame and produce a one-row output Otherwise: For a measure, produce a one-row output for the match For a window function, evaluate the function over a frame limited to the matched rows sequence and produce a one-row output Evaluate the AFTER MATCH SKIP clause, and mark the ‘skipped’ rows Empty matches and unmatched rows # If no match can be associated with a particular input row, the row is unmatched . This happens when no match can be found for the row. This also happens when no match is attempted for the row, because it is skipped by the AFTER MATCH SKIP clause of some preceding row. For an unmatched row, every row pattern measure is null . Every window function is evaluated over an empty frame. An empty match is a successful match which does not involve any pattern variables. In other words, an empty match does not contain any rows. If an empty match is associated with an input row, every row pattern measure for that row is evaluated over an empty sequence of rows. All navigation operations and the CLASSIFIER function return null . Every window function is evaluated over an empty frame. In most cases, the results for empty matches and unmatched rows are the same. A constant measure can be helpful to distinguish between them: The following call returns 'matched' for every matched row, including empty matches, and null for every unmatched row: matched OVER ( ... MEASURES 'matched' AS matched ... ) Previous VALUES Next Developer guide

Developer guide — Trino 474 Documentation Skip to content Trino 474 Documentation Developer guide  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax Developer guide Developer guide SPI overview Test writing guidelines Connectors Example HTTP connector Example JDBC connector Supporting INSERT and CREATE TABLE AS Supporting MERGE Types Functions Table functions System access control Password authenticator Certificate authenticator Header authenticator Group provider Event listener Trino client REST API Glossary Appendix Release notes Developer guide # This guide is intended for Trino contributors and plugin developers. Important information on processes, code style, reviews, and other details are available on the development section of the Trino website and in the development documentation in the Trino source code . SPI overview Test writing guidelines Connectors Example HTTP connector Example JDBC connector Supporting INSERT and CREATE TABLE AS Supporting MERGE Types Functions Table functions System access control Password authenticator Certificate authenticator Header authenticator Group provider Event listener Trino client REST API Previous Row pattern recognition in window structures Next SPI overview

Glossary — Trino 474 Documentation Skip to content Trino 474 Documentation Glossary  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax Developer guide Glossary Glossary Appendix Release notes Glossary # The glossary contains a list of key Trino terms and definitions. Catalog Catalogs define and name a configuration for connecting to a data source, allowing users to query the connected data. Each catalog’s configuration specifies a connector to define which data source the catalog connects to. For more information about catalogs, see Catalog . Certificate A public key certificate issued by a CA , sometimes abbreviated as cert, that verifies the ownership of a server’s private keys. Certificate format is specified in the X.509 standard. Certificate Authority (CA) A trusted organization that signs and issues certificates. Its signatures can be used to verify the validity of certificates . Cluster A Trino cluster provides the resources to run queries against numerous data sources. Clusters define the number of nodes, the configuration for the JVM runtime, configured data sources, and others aspects. For more information, see Cluster . Connector Translates data from a data source into Trino schemas, tables, columns, rows, and data types. A connector is specific to a data source, and is used in catalog configurations to define what data source the catalog connects to. A connector is one of many types of plugins Container A lightweight virtual package of software that contains libraries, binaries, code, configuration files, and other dependencies needed to deploy an application. A running container does not include an operating system, instead using the operating system of the host machine. To learn more, read read about containers in the Kubernetes documentation. Data source A system from which data is retrieved - for example, PostgreSQL or Iceberg on S3 data. In Trino, users query data sources with catalogs that connect to each source. See Data source for more information. Data virtualization Data virtualization is a method of abstracting an interaction with multiple heterogeneous data sources , without needing to know the distributed nature of the data, its format, or any other technical details involved in presenting the data. gzip gzip is a compression format and software that compresses and decompresses files. This format is used several ways in Trino, including deployment and compressing files in object storage . The most common extension for gzip-compressed files is .gz . HDFS Hadoop Distributed Filesystem (HDFS) is a scalable open source filesystem that was one of the earliest distributed big data systems created to store large amounts of data for the Hadoop ecosystem . Java KeyStore (JKS) The system of public key cryptography supported as one part of the Java security APIs. The legacy JKS system recognizes keys and certificates stored in keystore files, typically with the .jks extension, and by default relies on a system-level list of CAs in truststore files installed as part of the current Java installation. Key A cryptographic key specified as a pair of public and private strings generally used in the context of TLS to secure public network traffic. Load Balancer (LB) Software or a hardware device that sits on a network edge and accepts network connections on behalf of servers behind that wall, distributing traffic across network and server infrastructure to balance the load on networked services. Object storage Object storage is a file storage mechanism. Examples of compatible object stores include the following: Amazon S3 Google Cloud Storage Azure Blob Storage MinIO and other S3-compatible stores HDFS Open-source Typically refers to open-source software . which is software that has the source code made available for others to see, use, and contribute to. Allowed usage varies depending on the license that the software is licensed under. Trino is licensed under the Apache license , and is therefore maintained by a community of contributors from all across the globe. PEM file format A format for storing and sending cryptographic keys and certificates. PEM format can contain both a key and its certificate, plus the chain of certificates from authorities back to the root CA , or back to a CA vendor’s intermediate CA. PKCS #12 A binary archive used to store keys and certificates or certificate chains that validate a key. PKCS #12 files have .p12 or .pfx extensions. This format is a less popular alternative to PEM . Plugin A bundle of code implementing the Trino Service Provider Interface (SPI) . that is used to add new functionality. More information is available in Plugins . Presto and PrestoSQL The old name for Trino. To learn more about the name change to Trino, read the history . Query federation A type of data virtualization that provides a common access point and data model across two or more heterogeneous data sources. A popular data model used by many query federation engines is translating different data sources to SQL tables. Secure Sockets Layer (SSL) Now superseded by TLS , but still recognized as the term for what TLS does. Structured Query Language (SQL) The standard language used with relational databases. For more information, see SQL . Tarball A common abbreviation for TAR file , which is a common software distribution mechanism. This file format is a collection of multiple files distributed as a single file, commonly compressed using gzip compression. Transport Layer Security (TLS) TLS is a security protocol designed to provide secure communications over a network. It is the successor to SSL , and used in many applications like HTTPS, email, and Trino. These security topics use the term TLS to refer to both TLS and SSL. Previous Trino client REST API Next Appendix

Appendix — Trino 474 Documentation Skip to content Trino 474 Documentation Appendix  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax Developer guide Glossary Appendix Appendix Migrating from Hive Legal notices Release notes Appendix # Migrating from Hive Legal notices Previous Glossary Next Migrating from Hive

Release notes — Trino 474 Documentation Skip to content Trino 474 Documentation Release notes  Type to start searching Trino Trino 474 Documentation Trino Overview Installation Clients Security Administration Query optimizer Connectors Object storage Functions and operators User-defined functions SQL language SQL statement syntax Developer guide Glossary Appendix Release notes Release notes Contents 2025 2024 2023 2022 2021 2020 2019 Before 2019 Breaking changes Release 474 (21 Mar 2025) Release 473 (19 Mar 2025) Release 472 (5 Mar 2025) Release 471 (19 Feb 2025) Release 470 (5 Feb 2025) Release 469 (27 Jan 2025) Release 468 (17 Dec 2024) Release 467 (6 Dec 2024) Release 466 (27 Nov 2024) Release 465 (20 Nov 2024) Release 464 (30 Oct 2024) Release 463 (23 Oct 2024) Release 462 (16 Oct 2024) Release 461 (10 Oct 2024) Release 460 (3 Oct 2024) Release 459 (25 Sep 2024) Release 458 (17 Sep 2024) Release 457 (6 Sep 2024) Release 456 (6 Sep 2024) Release 455 (29 Aug 2024) Release 454 (15 Aug 2024) Release 453 (25 Jul 2024) Release 452 (11 Jul 2024) Release 451 (27 Jun 2024) Release 450 (19 Jun 2024) Release 449 (31 May 2024) Release 448 (15 May 2024) Release 447 (8 May 2024) Release 446 (1 May 2024) Release 445 (17 Apr 2024) Release 444 (3 Apr 2024) Release 443 (21 Mar 2024) Release 442 (14 Mar 2024) Release 441 (13 Mar 2024) Release 440 (8 Mar 2024) Release 439 (15 Feb 2024) Release 438 (1 Feb 2024) Release 437 (24 Jan 2024) Release 436 (11 Jan 2024) Release 435 (13 Dec 2023) Release 434 (29 Nov 2023) Release 433 (10 Nov 2023) Release 432 (2 Nov 2023) Release 431 (27 Oct 2023) Release 430 (20 Oct 2023) Release 429 (11 Oct 2023) Release 428 (4 Oct 2023) Release 427 (26 Sep 2023) Release 426 (5 Sep 2023) Release 425 (24 Aug 2023) Release 424 (17 Aug 2023) Release 423 (10 Aug 2023) Release 422 (13 Jul 2023) Release 421 (6 Jul 2023) Release 420 (22 Jun 2023) Release 419 (5 Jun 2023) Release 418 (17 May 2023) Release 417 (10 May 2023) Release 416 (3 May 2023) Release 415 (28 Apr 2023) Release 414 (19 Apr 2023) Release 413 (12 Apr 2023) Release 412 (5 Apr 2023) Release 411 (29 Mar 2023) Release 410 (8 Mar 2023) Release 409 (3 Mar 2023) Release 408 (23 Feb 2023) Release 407 (16 Feb 2023) Release 406 (25 Jan 2023) Release 405 (28 Dec 2022) Release 404 (???) Release 403 (15 Nov 2022) Release 402 (2 Nov 2022) Release 401 (26 Oct 2022) Release 400 (13 Oct 2022) Release 399 (6 Oct 2022) Release 398 (28 Sep 2022) Release 397 (21 Sep 2022) Release 396 (15 Sep 2022) Release 395 (7 Sep 2022) Release 394 (29 Aug 2022) Release 393 (17 Aug 2022) Release 392 (3 Aug 2022) Release 391 (22 Jul 2022) Release 390 (13 Jul 2022) Release 389 (7 Jul 2022) Release 388 (29 Jun 2022) Release 387 (22 Jun 2022) Release 386 (15 Jun 2022) Release 385 (8 Jun 2022) Release 384 (3 Jun 2022) Release 383 (1 Jun 2022) Release 382 (25 May 2022) Release 381 (16 May 2022) Release 380 (6 May 2022) Release 379 (28 Apr 2022) Release 378 (21 Apr 2022) Release 377 (13 Apr 2022) Release 376 (7 Apr 2022) Release 375 (28 Mar 2022) Release 374 (17 Mar 2022) Release 373 (9 Mar 2022) Release 372 (2 Mar 2022) Release 371 (16 Feb 2022) Release 370 (3 Feb 2022) Release 369 (24 Jan 2022) Release 368 (11 Jan 2022) Release 367 (22 Dec 2021) Release 366 (14 Dec 2021) Release 365 (3 Dec 2021) Release 364 (1 Nov 2021) Release 363 (6 Oct 2021) Release 362 (20 Sep 2021) Release 361 (27 Aug 2021) Release 360 (30 Jul 2021) Release 359 (1 Jul 2021) Release 358 (1 Jun 2021) Release 357 (21 May 2021) Release 356 (30 Apr 2021) Release 355 (8 Apr 2021) Release 354 (19 Mar 2021) Release 353 (5 Mar 2021) Release 352 (9 Feb 2021) Release 351 (3 Jan 2021) Release 350 (28 Dec 2020) Release 349 (28 Dec 2020) Release 348 (14 Dec 2020) Release 347 (25 Nov 2020) Release 346 (10 Nov 2020) Release 345 (23 Oct 2020) Release 344 (9 Oct 2020) Release 343 (25 Sep 2020) Release 342 (24 Sep 2020) Release 341 (8 Sep 2020) Release 340 (8 Aug 2020) Release 339 (21 Jul 2020) Release 338 (07 Jul 2020) Release 337 (25 Jun 2020) Release 336 (16 Jun 2020) Release 335 (14 Jun 2020) Release 334 (29 May 2020) Release 333 (04 May 2020) Release 332 (08 Apr 2020) Release 331 (16 Mar 2020) Release 330 (18 Feb 2020) Release 329 (23 Jan 2020) Release 328 (10 Jan 2020) Release 327 (20 Dec 2019) Release 326 (27 Nov 2019) Release 325 (14 Nov 2019) Release 324 (1 Nov 2019) Release 323 (23 Oct 2019) Release 322 (16 Oct 2019) Release 321 (15 Oct 2019) Release 320 (10 Oct 2019) Release 319 (22 Sep 2019) Release 318 (26 Aug 2019) Release 317 (1 Aug 2019) Release 316 (8 Jul 2019) Release 315 (14 Jun 2019) Release 314 (7 Jun 2019) Release 313 (31 May 2019) Release 312 (29 May 2019) Release 311 (14 May 2019) Release 310 (3 May 2019) Release 309 (25 Apr 2019) Release 308 (11 Apr 2019) Release 307 (3 Apr 2019) Release 306 (16 Mar 2019) Release 305 (7 Mar 2019) Release 304 (27 Feb 2019) Release 303 (13 Feb 2019) Release 302 (6 Feb 2019) Release 301 (31 Jan 2019) Release 300 (22 Jan 2019) Release 0.215 Release 0.214 Release 0.213 Release 0.212 Release 0.211 Release 0.210 Release 0.209 Release 0.208 Release 0.207 Release 0.206 Release 0.205 Release 0.204 Release 0.203 Release 0.202 Release 0.201 Release 0.200 Release 0.199 Release 0.198 Release 0.197 Release 0.196 Release 0.195 Release 0.194 Release 0.193 Release 0.192 Release 0.191 Release 0.190 Release 0.189 Release 0.188 Release 0.187 Release 0.186 Release 0.185 Release 0.184 Release 0.183 Release 0.182 Release 0.181 Release 0.180 Release 0.179 Release 0.178 Release 0.177 Release 0.176 Release 0.175 Release 0.174 Release 0.173 Release 0.172 Release 0.171 Release 0.170 Release 0.169 Release 0.168 Release 0.167 Release 0.166 Release 0.165 Release 0.164 Release 0.163 Release 0.162 Release 0.161 Release 0.160 Release 0.159 Release 0.158 Release 0.157.1 Release 0.157 Release 0.156 Release 0.155 Release 0.154 Release 0.153 Release 0.152.3 Release 0.152.2 Release 0.152.1 Release 0.152 Release 0.151 Release 0.150 Release 0.149 Release 0.148 Release 0.147 Release 0.146 Release 0.145 Release 0.144.7 Release 0.144.6 Release 0.144.5 Release 0.144.4 Release 0.144.3 Release 0.144.2 Release 0.144.1 Release 0.144 Release 0.143 Release 0.142 Release 0.141 Release 0.140 Release 0.139 Release 0.138 Release 0.137 Release 0.136 Release 0.135 Release 0.134 Release 0.133 Release 0.132 Release 0.131 Release 0.130 Release 0.129 Release 0.128 Release 0.127 Release 0.126 Release 0.125 Release 0.124 Release 0.123 Release 0.122 Release 0.121 Release 0.120 Release 0.119 Release 0.118 Release 0.117 Release 0.116 Release 0.115 Release 0.114 Release 0.113 Release 0.112 Release 0.111 Release 0.110 Release 0.109 Release 0.108 Release 0.107 Release 0.106 Release 0.105 Release 0.104 Release 0.103 Release 0.102 Release 0.101 Release 0.100 Release 0.99 Release 0.98 Release 0.97 Release 0.96 Release 0.95 Release 0.94 Release 0.93 Release 0.92 Release 0.91 Release 0.90 Release 0.89 Release 0.88 Release 0.87 Release 0.86 Release 0.85 Release 0.84 Release 0.83 Release 0.82 Release 0.81 Release 0.80 Release 0.79 Release 0.78 Release 0.77 Release 0.76 Release 0.75 Release 0.74 Release 0.73 Release 0.72 Release 0.71 Release 0.70 Release 0.69 Release 0.68 Release 0.67 Release 0.66 Release 0.65 Release 0.64 Release 0.63 Release 0.62 Release 0.61 Release 0.60 Release 0.59 Release 0.58 Release 0.57 Release 0.56 Release 0.55 Release 0.54 Contents 2025 2024 2023 2022 2021 2020 2019 Before 2019 Breaking changes Release notes # 2025 # Release 474 (21 Mar 2025) Release 473 (19 Mar 2025) Release 472 (5 Mar 2025) Release 471 (19 Feb 2025) Release 470 (5 Feb 2025) Release 469 (27 Jan 2025) 2024 # Release 468 (17 Dec 2024) Release 467 (6 Dec 2024) Release 466 (27 Nov 2024) Release 465 (20 Nov 2024) Release 464 (30 Oct 2024) Release 463 (23 Oct 2024) Release 462 (16 Oct 2024) Release 461 (10 Oct 2024) Release 460 (3 Oct 2024) Release 459 (25 Sep 2024) Release 458 (17 Sep 2024) Release 457 (6 Sep 2024) Release 456 (6 Sep 2024) Release 455 (29 Aug 2024) Release 454 (15 Aug 2024) Release 453 (25 Jul 2024) Release 452 (11 Jul 2024) Release 451 (27 Jun 2024) Release 450 (19 Jun 2024) Release 449 (31 May 2024) Release 448 (15 May 2024) Release 447 (8 May 2024) Release 446 (1 May 2024) Release 445 (17 Apr 2024) Release 444 (3 Apr 2024) Release 443 (21 Mar 2024) Release 442 (14 Mar 2024) Release 441 (13 Mar 2024) Release 440 (8 Mar 2024) Release 439 (15 Feb 2024) Release 438 (1 Feb 2024) Release 437 (24 Jan 2024) Release 436 (11 Jan 2024) 2023 # Release 435 (13 Dec 2023) Release 434 (29 Nov 2023) Release 433 (10 Nov 2023) Release 432 (2 Nov 2023) Release 431 (27 Oct 2023) Release 430 (20 Oct 2023) Release 429 (11 Oct 2023) Release 428 (4 Oct 2023) Release 427 (26 Sep 2023) Release 426 (5 Sep 2023) Release 425 (24 Aug 2023) Release 424 (17 Aug 2023) Release 423 (10 Aug 2023) Release 422 (13 Jul 2023) Release 421 (6 Jul 2023) Release 420 (22 Jun 2023) Release 419 (5 Jun 2023) Release 418 (17 May 2023) Release 417 (10 May 2023) Release 416 (3 May 2023) Release 415 (28 Apr 2023) Release 414 (19 Apr 2023) Release 413 (12 Apr 2023) Release 412 (5 Apr 2023) Release 411 (29 Mar 2023) Release 410 (8 Mar 2023) Release 409 (3 Mar 2023) Release 408 (23 Feb 2023) Release 407 (16 Feb 2023) Release 406 (25 Jan 2023) 2022 # Release 405 (28 Dec 2022) Release 404 (???) Release 403 (15 Nov 2022) Release 402 (2 Nov 2022) Release 401 (26 Oct 2022) Release 400 (13 Oct 2022) Release 399 (6 Oct 2022) Release 398 (28 Sep 2022) Release 397 (21 Sep 2022) Release 396 (15 Sep 2022) Release 395 (7 Sep 2022) Release 394 (29 Aug 2022) Release 393 (17 Aug 2022) Release 392 (3 Aug 2022) Release 391 (22 Jul 2022) Release 390 (13 Jul 2022) Release 389 (7 Jul 2022) Release 388 (29 Jun 2022) Release 387 (22 Jun 2022) Release 386 (15 Jun 2022) Release 385 (8 Jun 2022) Release 384 (3 Jun 2022) Release 383 (1 Jun 2022) Release 382 (25 May 2022) Release 381 (16 May 2022) Release 380 (6 May 2022) Release 379 (28 Apr 2022) Release 378 (21 Apr 2022) Release 377 (13 Apr 2022) Release 376 (7 Apr 2022) Release 375 (28 Mar 2022) Release 374 (17 Mar 2022) Release 373 (9 Mar 2022) Release 372 (2 Mar 2022) Release 371 (16 Feb 2022) Release 370 (3 Feb 2022) Release 369 (24 Jan 2022) Release 368 (11 Jan 2022) 2021 # Release 367 (22 Dec 2021) Release 366 (14 Dec 2021) Release 365 (3 Dec 2021) Release 364 (1 Nov 2021) Release 363 (6 Oct 2021) Release 362 (20 Sep 2021) Release 361 (27 Aug 2021) Release 360 (30 Jul 2021) Release 359 (1 Jul 2021) Release 358 (1 Jun 2021) Release 357 (21 May 2021) Release 356 (30 Apr 2021) Release 355 (8 Apr 2021) Release 354 (19 Mar 2021) Release 353 (5 Mar 2021) Release 352 (9 Feb 2021) Release 351 (3 Jan 2021) 2020 # Release 350 (28 Dec 2020) Release 349 (28 Dec 2020) Release 348 (14 Dec 2020) Release 347 (25 Nov 2020) Release 346 (10 Nov 2020) Release 345 (23 Oct 2020) Release 344 (9 Oct 2020) Release 343 (25 Sep 2020) Release 342 (24 Sep 2020) Release 341 (8 Sep 2020) Release 340 (8 Aug 2020) Release 339 (21 Jul 2020) Release 338 (07 Jul 2020) Release 337 (25 Jun 2020) Release 336 (16 Jun 2020) Release 335 (14 Jun 2020) Release 334 (29 May 2020) Release 333 (04 May 2020) Release 332 (08 Apr 2020) Release 331 (16 Mar 2020) Release 330 (18 Feb 2020) Release 329 (23 Jan 2020) Release 328 (10 Jan 2020) 2019 # Release 327 (20 Dec 2019) Release 326 (27 Nov 2019) Release 325 (14 Nov 2019) Release 324 (1 Nov 2019) Release 323 (23 Oct 2019) Release 322 (16 Oct 2019) Release 321 (15 Oct 2019) Release 320 (10 Oct 2019) Release 319 (22 Sep 2019) Release 318 (26 Aug 2019) Release 317 (1 Aug 2019) Release 316 (8 Jul 2019) Release 315 (14 Jun 2019) Release 314 (7 Jun 2019) Release 313 (31 May 2019) Release 312 (29 May 2019) Release 311 (14 May 2019) Release 310 (3 May 2019) Release 309 (25 Apr 2019) Release 308 (11 Apr 2019) Release 307 (3 Apr 2019) Release 306 (16 Mar 2019) Release 305 (7 Mar 2019) Release 304 (27 Feb 2019) Release 303 (13 Feb 2019) Release 302 (6 Feb 2019) Release 301 (31 Jan 2019) Release 300 (22 Jan 2019) Before 2019 # Release 0.215 Release 0.214 Release 0.213 Release 0.212 Release 0.211 Release 0.210 Release 0.209 Release 0.208 Release 0.207 Release 0.206 Release 0.205 Release 0.204 Release 0.203 Release 0.202 Release 0.201 Release 0.200 Release 0.199 Release 0.198 Release 0.197 Release 0.196 Release 0.195 Release 0.194 Release 0.193 Release 0.192 Release 0.191 Release 0.190 Release 0.189 Release 0.188 Release 0.187 Release 0.186 Release 0.185 Release 0.184 Release 0.183 Release 0.182 Release 0.181 Release 0.180 Release 0.179 Release 0.178 Release 0.177 Release 0.176 Release 0.175 Release 0.174 Release 0.173 Release 0.172 Release 0.171 Release 0.170 Release 0.169 Release 0.168 Release 0.167 Release 0.166 Release 0.165 Release 0.164 Release 0.163 Release 0.162 Release 0.161 Release 0.160 Release 0.159 Release 0.158 Release 0.157.1 Release 0.157 Release 0.156 Release 0.155 Release 0.154 Release 0.153 Release 0.152.3 Release 0.152.2 Release 0.152.1 Release 0.152 Release 0.151 Release 0.150 Release 0.149 Release 0.148 Release 0.147 Release 0.146 Release 0.145 Release 0.144.7 Release 0.144.6 Release 0.144.5 Release 0.144.4 Release 0.144.3 Release 0.144.2 Release 0.144.1 Release 0.144 Release 0.143 Release 0.142 Release 0.141 Release 0.140 Release 0.139 Release 0.138 Release 0.137 Release 0.136 Release 0.135 Release 0.134 Release 0.133 Release 0.132 Release 0.131 Release 0.130 Release 0.129 Release 0.128 Release 0.127 Release 0.126 Release 0.125 Release 0.124 Release 0.123 Release 0.122 Release 0.121 Release 0.120 Release 0.119 Release 0.118 Release 0.117 Release 0.116 Release 0.115 Release 0.114 Release 0.113 Release 0.112 Release 0.111 Release 0.110 Release 0.109 Release 0.108 Release 0.107 Release 0.106 Release 0.105 Release 0.104 Release 0.103 Release 0.102 Release 0.101 Release 0.100 Release 0.99 Release 0.98 Release 0.97 Release 0.96 Release 0.95 Release 0.94 Release 0.93 Release 0.92 Release 0.91 Release 0.90 Release 0.89 Release 0.88 Release 0.87 Release 0.86 Release 0.85 Release 0.84 Release 0.83 Release 0.82 Release 0.81 Release 0.80 Release 0.79 Release 0.78 Release 0.77 Release 0.76 Release 0.75 Release 0.74 Release 0.73 Release 0.72 Release 0.71 Release 0.70 Release 0.69 Release 0.68 Release 0.67 Release 0.66 Release 0.65 Release 0.64 Release 0.63 Release 0.62 Release 0.61 Release 0.60 Release 0.59 Release 0.58 Release 0.57 Release 0.56 Release 0.55 Release 0.54 Breaking changes # Starting with Trino 432, release notes include a ⚠️ symbol to highlight any changes as potentially breaking changes. The following changes are considered and may require adjustments: Removal or renaming of configuration properties that may prevent startup or require configuration changes Changes to default values for configuration properties that may significantly change the behavior of a system Updates to the requirements for external systems or software used with Trino, such as removal of support for an old version of a data source in a connector Non-backwards compatible changes to the SPI which may require plugins to be updated Otherwise significant changes that requires specific attention from teams managing a Trino deployment Previous Legal notices Next Release 474 (21 Mar 2025)

